Введение
Цели:
Научится работать с графами, создавать программы определяющие виды графов

Задача:
Найти компоненты связанности неориентированного графа

Вариант:
2.9 (матрица инциндентности)

Определения:
Матрица инцидентности — одна из форм представления графа, в которой указываются связи между инцидентными элементами графа (ребро (дуга) и вершина). Столбцы матрицы соответствуют рёбрам, строки — вершинам. Ненулевое значение в ячейке матрицы указывает на связь между вершиной и ребром (их инцидентность).

Граф — математическая абстракция реальной системы любой природы, объекты которой обладают парными связями. Граф как математический объект представляет собой совокупность двух множеств — множества самих объектов, называемого множеством вершин, и множества их парных связей, называемого множеством рёбер. Элемент множества рёбер — это пара элементов множества вершин.

Инцидентность — понятие, используемое только в отношении ребра и вершины. Две вершины или два ребра не могут быть инцидентными.

Компонента связности графа — некоторое подмножество вершин графа, такое, что для любых двух вершин из этого множества существует путь из одной в другую, и не существует пути из вершины этого множества в вершину, не принадлежащую этому множеству.изображение

Алгоритм
Определение параметров:

1) Задайте максимальное количество вершин (MAX_VERTICES) и рёбер (MAX_EDGES).
Объявите матрицу инцидентности graph[MAX_VERTICES][MAX_EDGES] для представления графа.
Создайте массив visited[MAX_VERTICES] для отслеживания посещенных вершин (если это понадобится в дальнейшем).
Запрос данных у пользователя:

2) Запросите у пользователя количество вершин numVertices и количество рёбер numEdges.
Проверьте, чтобы numVertices находилось в диапазоне от 1 до MAX_VERTICES, а numEdges не было отрицательным.

3)Инициализация матрицы инцидентности:
Инициализируйте матрицу инцидентности нулями.

4) Ввод матрицы инцидентности:
Запросите у пользователя ввод значений в матрицу инцидентности размером numVertices x numEdges.

5) Вывод матрицы инцидентности:
Выведите матрицу инцидентности на экран.

6)Подсчет хорд:

Вызовите функцию countChords, передав ей матрицу инцидентности, количество вершин и количество рёбер.
Функция должна:
Перебирать все пары вершин.
Проверять, являются ли вершины соседями (имеют ли общее ребро).
Если не являются соседями, проверить, есть ли путь между ними через других соседей.
Увеличивать счетчик хорд, если пара вершин образует хорду.

7)Вывод результата:

Выведите количество найденных хорд.


Код программы:
#include <iostream>

using namespace std;

const int MAX_VERTICES = 100; // Максимальное количество вершин в графе

// Функция для нахождения хорд в неориентированном графе
int countChords(int incidenceMatrix[MAX_VERTICES][MAX_VERTICES], int numVertices, int numEdges) {
    int chordCount = 0;

    // Перебираем все пары вершин
    for (int i = 0; i < numVertices; ++i) {
        for (int j = i + 1; j < numVertices; ++j) {
            // Проверяем, являются ли i и j соседями (инцидентными)
            bool areNeighbors = false;
            for (int k = 0; k < numEdges; ++k) {
                if (incidenceMatrix[i][k] == 1 && incidenceMatrix[j][k] == 1) {
                    areNeighbors = true; // i и j имеют общее ребро
                    break;
                }
            }

            // Если i и j не соседи, проверяем, образует ли эта пара хорду в цикле
            if (!areNeighbors) {
                // Проверяем, существует ли путь между i и j через других соседей
                bool isChord = true;
                for (int k = 0; k < numVertices; ++k) {
                    if (k != i && k != j) {
                        if (incidenceMatrix[i][k] == 1 && incidenceMatrix[j][k] == 1) {
                            isChord = false; // Если есть путь между i и j через соседей, это не хорда
                            break;
                        }
                    }
                }
                if (isChord) {
                    chordCount++; // Это хорда
                }
            }
        }
    }

    return chordCount;
}

int main() {
    int numVertices, numEdges;

    setlocale(LC_ALL, "ru");

    // Запрашиваем количество вершин и количество ребер у пользователя
    cout << "Введите количество вершин (максимум " << MAX_VERTICES << "): ";
    cin >> numVertices;

    cout << "Введите количество ребер: ";
    cin >> numEdges;

    // Проверка на допустимое количество вершин и ребер
    if (numVertices < 1 || numVertices > MAX_VERTICES || numEdges < 0) {
        cout << "Ошибка: количество вершин должно быть в диапазоне от 1 до " << MAX_VERTICES << ", количество ребер не должно быть отрицательным." << endl;
        return 1;
    }

    int incidenceMatrix[MAX_VERTICES][MAX_VERTICES] = { 0 }; // Инициализация матрицы инцидентности

    // Ввод матрицы инцидентности
    cout << "Введите матрицу инцидентности (размер " << numVertices << " x " << numEdges << "):" << endl;
    for (int i = 0; i < numVertices; ++i) {
        for (int j = 0; j < numEdges; ++j) {
            cin >> incidenceMatrix[i][j];
        }
    }

    // Вывод матрицы инцидентности
    cout << "Матрица инцидентности графа:" << endl;
    for (int i = 0; i < numVertices; ++i) {
        for (int j = 0; j < numEdges; ++j) {
            cout << incidenceMatrix[i][j] << " ";
        }
        cout << endl;
    }

    // Подсчет хорд
    int chordCount = countChords(incidenceMatrix, numVertices, numEdges);
    cout << "Количество хорд в графе: " << chordCount << endl;

    return 0;
}
