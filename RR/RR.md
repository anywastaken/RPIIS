# Расчетная работа 

## Введение

### Цели: 
Научится работать и проводить различные операции с графами.

### Задача: 
Найти мосты в неориентированном графе.
### Вариант: 
5.15 (матрица инцидентности)

### Определения:

`Матрица инцидентности` — одна из форм представления графа, в которой указываются связи между инцидентными элементами графа (ребро(дуга) и вершина). Столбцы матрицы соответствуют ребрам, строки — вершинам. Ненулевое значение в ячейке матрицы указывает связь между вершиной и ребром (их инцидентность).

`Инцидентность` — понятие, используемое только в отношении ребра и вершины. Две вершины или два ребра не могут быть инцидентны.

`Граф` — математическая абстракция реальной системы любой природы, объекты которой обладают парными связями. Граф как математический объект есть совокупность двух множеств — множества самих объектов, называемого множеством вершин, и множества их парных связей, называемого множеством рёбер. Элемент множества рёбер есть пара элементов множества вершин.

`Неориентированный граф` - это граф, где рёбра не имеют направления, что делает связь между вершинами двусторонней.

### Алгоритм:
1.Пользователь вводит количество вершин и рёбер графа.              
2.Затем вводится матрица инцидентности, где строки представляют вершины, а столбцы — рёбра.             
3.Функция matrixToAdjList преобразует матрицу инцидентности в список смежности.            
4.Используется DFS для обхода графа.              
5.После завершения DFS алгоритм выводит все найденные мосты в графе.           
## Код программы:
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// Функция для поиска мостов (DFS)

void dfs(int v, int parent, vector<vector<int>>& adj, vector<int>& visited, vector<int>& tin, vector<int>& low, int& timer, vector<pair<int, int>>& bridges) {
    visited[v] = 1;
    tin[v] = low[v] = timer++;

    for (int to : adj[v]) {
        if (to == parent) continue; // Пропускаем ребро к родительской вершине
        if (visited[to]) {
            // Обновляем значение low, если "to" уже посещена
            low[v] = min(low[v], tin[to]);
        }
        else {
            dfs(to, v, adj, visited, tin, low, timer, bridges);
            low[v] = min(low[v], low[to]);
            if (low[to] > tin[v]) {
                bridges.emplace_back(v, to);
            }
        }
    }
}

// Преобразование матрицы инцидентности в список смежности
vector<vector<int>> matrixToAdjList(const vector<vector<int>>& incMatrix) {
    int n = incMatrix.size(); // Число вершин
    int m = incMatrix[0].size(); // Число рёбер
    vector<vector<int>> adj(n);

    for (int j = 0; j < m; ++j) {
        int u = -1, v = -1;
        for (int i = 0; i < n; ++i) {
            if (incMatrix[i][j] == 1) {
                if (u == -1) u = i;
                else v = i;
            }
        }
        if (u != -1 && v != -1) {
            adj[u].push_back(v);
            adj[v].push_back(u);
        }
    }
    return adj;
}

int main() {
    int n, m;
    setlocale(LC_ALL, "Rus");
    cout << "Введите количество вершин и рёбер: ";
    cin >> n >> m;

    vector<vector<int>> incMatrix(n, vector<int>(m));
    cout << "Введите матрицу инцидентности (строки - вершины, столбцы - рёбра):\n";
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            cin >> incMatrix[i][j];
        }
    }

    // Преобразуем матрицу инцидентности в список смежности
    vector<vector<int>> adj = matrixToAdjList(incMatrix);

    // Подготовка переменных для алгоритма
    vector<int> visited(n, 0), tin(n, -1), low(n, -1);
    vector<pair<int, int>> bridges;
    int timer = 0;

    // Запускаем DFS для поиска мостов
    for (int i = 0; i < n; ++i) {
        if (!visited[i]) {
            dfs(i, -1, adj, visited, tin, low, timer, bridges);
        }
    }

    // Вывод мостов
    cout << "Мосты в графе:\n";
    for (const auto& bridge : bridges) {
        cout << bridge.first << " - " << bridge.second << "\n";
    }

    return 0;
}

```
## Пример графа:
![](график1.png)
## Работа кода:
![](код1.png)

## Пример графа:
![](график2.png)
## Работа кода:
![](код2.png)

## Пример графа:
![](график3.png)
## Работа кода:
![](код3.png)


 ## Вывод
 В результате выполнения данной работы изучил и применил базовые алгоритмы для работы с графами.
  
  
