# Расчётная работа

---

### Цели:
* изучить основные виды графов,
* научиться создавать алгоритмы для обработки графов,
* реализовать алгоритм на языке С++

## Задание:
Создать программу, которая находит число хорд в неориентированном графе. На вход подаётся матрица инцидентности.

### Основные понятия:
***Граф*** — математическая абстракция реальной системы любой природы, объекты которой обладают парными связями. Граф как математический объект есть совокупность двух множеств — множества самих объектов, называемого множеством вершин, и множества их парных связей, называемого множеством рёбер. Элемент множества рёбер есть пара элементов множества вершин.

***Матрица инцидентности*** — одна из форм представления графа, в которой указываются связи между инцидентными элементами графа (ребро(дуга) и вершина). Столбцы матрицы соответствуют ребрам, строки — вершинам. Ненулевое значение в ячейке матрицы указывает связь между вершиной и ребром (их инцидентность).

***Неориентированный граф*** — Граф, ни одному ребру которого не присвоено направление.

***Цикл*** — граф, состоящий из единственного цикла, или, другими словами, некоторого числа вершин, соединённых замкнутой цепью.

***Хордальный граф*** — граф, каждый из циклов которого, имеющих четыре ребра и более, имеет хорду (ребро, соединяющее две вершины цикла, но не являющееся его частью). 

**Пример хордального графа:** 

![Chordal-graph svg](https://github.com/user-attachments/assets/9ea55ef0-0183-4d9e-971c-c233072a4f28)

#### Ввод матрицы инцидентности.
Введём матрицу с помощью вектора векторов:
```
int nodes, edges;
cout << "Введите количество вершин и рёбер: ";
cin >> nodes >> edges;
vector<vector<int>> incidenceMatrix(nodes, vector<int>(edges));
cout << "Введите матрицу инцидентности: ";
for (int i = 0; i < nodes; i++) {
	for (int j = 0; j < edges; j++) {
		cin >> incidenceMatrix[i][j];
	}
}
```
Это матрица инцидентности предыдущего графа.

### Тестовые примеры:

![граф1](https://github.com/user-attachments/assets/71e5d989-bf51-458e-83b8-d7a8f4fecd17)

Матрица 1:
```
1 0 0 0 0 0 0 0 1
1 1 1 1 1 0 0 0 0
0 1 0 0 0 1 0 0 0
0 0 0 0 1 1 1 0 0
0 0 0 1 0 0 1 1 0
0 0 1 0 0 0 0 1 1
```
Вывод программы: Число хорд в неориентированном графе: 3

![Граф2](https://github.com/user-attachments/assets/81597546-85ac-4223-a715-41ed125d0c3d)

Матрица 2:
```
1 0 0 0 0 1 0 0 0
1 1 0 0 0 0 1 1 0
0 1 1 0 0 0 0 0 1
0 0 1 1 0 0 0 0 0
0 0 0 1 1 0 0 1 1
0 0 0 0 1 1 1 0 0
```
Вывод программы: Число хорд в неориентированном графе: 3

![Граф3](https://github.com/user-attachments/assets/1d75f926-d215-4aa0-b94b-f66cf2e8bf32)

Матрица 3:
```
1 0 0 0 0 0 1 0 0 1
1 1 0 0 0 0 0 1 1 0
0 1 1 1 0 0 0 0 0 0
0 0 1 0 1 0 0 0 0 0
0 0 0 1 1 1 1 0 1 0
0 0 0 0 0 1 0 1 0 1
```
Вывод программы: Число хорд в неориентированном графе: 4

![Граф4](https://github.com/user-attachments/assets/ff26be12-8b40-4f39-803b-e6531749099e)

Матрица 4:
```
1 0 0 0 0 0 0 1 1 0 0 0 0 0 0
1 1 0 0 0 0 0 0 0 1 1 1 0 0 0
0 1 1 0 0 0 0 0 0 0 0 0 1 1 1
0 0 1 1 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 1 0 0 0 0 0 0 0 0 0 1
0 0 0 0 1 1 0 0 0 0 0 1 0 1 0
0 0 0 0 0 1 1 0 1 0 1 0 1 0 0
0 0 0 0 0 0 1 1 0 1 0 0 0 0 0
```
Вывод программы: Число хорд в неориентированном графе: 7

### Алгоритм:

#### Последовательность действий такая:
*Ищем все циклы с количеством рёбер 4 и больше,
*Запоминаем рёбра, которые входят в эти циклы,
*Выводим их количество.
**Сначала обЪявляем вектор векторов для найденных циклов:** 
```
for (int i = 0; i < n; i++) {
    for (int j = i + 1; j < n; j++) {
        if (incidenceMatrix[i][j] == 0) {
            int k = -1;
            for (int l = 0; l < n; l++) {
                if (incidenceMatrix[i][l] == 1 && incidenceMatrix[j][l] == 1) {
                    k = l;
                    break;
```
Если такой треугольник найден, проверяем, смежны ли его рёбра с другими вершинами (также ищем единицы):
```
bool isChord = true;
for (int m = 0; m < n; m++) {
    if (m != i && m != j && incidenceMatrix[i][m] == 1 && incidenceMatrix[j][m] == 1 && incidenceMatrix[k][m] == 1) {
        isChord = false;
        break;
    }
}
```
Если `true` увеличиваем счётчик хорд на 1.
В `main` создаём матрицу инцидентности и вызываем для неё функцию счёта хорд.
### Вывод:
В ходе выполнения данной расчетной работы были изучены основные понятия о графах, о способах их представления(матрица инцидентности графа). Для решения поставленной задачи мною был составлен и записан алгоритм языке программирования C++

---

### Использованные источники:
* Википедия. [Хордальный граф](https://ru.wikipedia.org/wiki/%D0%A5%D0%BE%D1%80%D0%B4%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%B3%D1%80%D0%B0%D1%84)
* [Habr](https://habr.com/ru/companies/otus/articles/568026/)
* [Сайт](https://translated.turbopages.org/proxy_u/en-ru.ru.538d906f-6754244e-1ae5a4af-74722d776562/https/www.geeksforgeeks.org/what-is-chordal-graphs/)
