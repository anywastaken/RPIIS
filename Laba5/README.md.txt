# Лабораторная работа 5
 
### Цель: 
 
Освоить командные оболочки shell (для OS семейства Unix) и cmd (для OS семейства MS Windows):
+ изучить основные встроенные команды,
+ научиться писать файлы сценариев,
+ научиться соотносить командные оболочки для разных OS.
+ Освоить командное окружение для OS семейства Unix(утилиты из пакета GNU Core Utilities), и соответствующие им утилиты для OS семейства MS Windows.
### Условия задания
Вариант 55: Создать файл sh и bat, который выполняет следующее: 
На вход пакетному файлу приходит относительный или абсолютный путь к папке (как параметры пакетного файла). Пакетный файл синхронизирует содержимое первой папки с содержимым второй папкой. В первой папке должен оказаться тот же набор файлов, что и во второй (если файла нет – он копируется из второй, если найдется файл, которого нет во второй - удаляется из первой). Если файл с некоторым именем есть и в первой папке и во второй папке – удалять и перезаписывать его не допускается

## Batch файл
- ### Код программы :computer:
```batch
@echo off
chcp 65001
setlocal

if "%~1"=="" (
    echo Укажите путь к папке-источнику.
    exit /b 1
)

if "%~2"=="" (
    echo Укажите путь к папке-назначению.
    exit /b 1
)

set "source=%~1"
set "destination=%~2"

for %%F in ("%destination%\*") do (
    if not exist "%source%\%%~nxF" (
        echo Копируем %%~nxF из %destination% в %source%
        copy "%%F" "%source%\"
    )
)

for %%F in ("%source%\*") do (
    if not exist "%destination%\%%~nxF" (
        echo Удаляем %%~nxF из %source%
        del "%%F"
    )
)

echo Синхронизация завершена.
endlocal
```
### Пример работы кода
![](lb5.png)

### Пояснение кода
Отключает вывод команд в командной строке, что делает вывод более чистым и удобным для пользователя.
```
@echo off
```
Устанавливает кодировку UTF-8, чтобы корректно отображать кириллические символы.
```
chcp 65001
```
Начинает локальный контекст переменных.
```
setlocal
```
Проверяет, передан ли первый аргумент (%~1), который должен содержать путь к папке-источнику. Если аргумент не указан (пустой), выводит сообщение об ошибке и завершает выполнение скрипта с кодом 1.```
if "%~1"=="" (
    echo Укажите путь к папке-источнику.
    exit /b 1
)
```
Аналогично, проверяет, передан ли второй аргумент (%~2), который должен содержать путь к папке-назначению. Если аргумент не указан, выводит сообщение об ошибке и завершает выполнение скрипта с кодом 1.
```
if "%~2"=="" (
    echo Укажите путь к папке-назначению.
    exit /b 1
)
```
Устанавливает переменные source и destination, присваивая им значения, переданные как аргументы при запуске скрипта. %~1 и %~2 содержат пути к папкам-источнику и -назначению соответственно.

```
set "source=%~1"
set "destination=%~2"
```
Цикл for, который проходит по всем файлам в папке-назначении (%destination%).
%%F — это переменная цикла, которая будет содержать полный путь к каждому файлу в папке-назначении.
if not exist "%source%\%%~nxF" проверяет, существует ли файл с таким же именем в папке-источнике. %%~nxF извлекает имя файла с расширением из переменной %%F.
Если файл не существует в папке-источнике, то:
Выводится сообщение о копировании файла из папки-назначения в папку-источник.
Файл копируется с помощью команды copy.
```
for %%F in ("%destination%\*") do (
    if not exist "%source%\%%~nxF" (
        echo Копируем %%~nxF из %destination% в %source%
        copy "%%F" "%source%\"
    )
)
```
Цикл for, который проходит по всем файлам в папке-источнике (%source%).
%%F — это переменная цикла, которая будет содержать полный путь к каждому файлу в папке-источнике.
if not exist "%destination%\%%~nxF" проверяет, существует ли файл с таким же именем в папке-назначении.
Если файл не существует в папке-назначении, то:
Выводится сообщение о том, что файл будет удален из папки-источника.
Файл удаляется с помощью команды del.
```
for %%F in ("%source%\*") do (
    if not exist "%destination%\%%~nxF" (
        echo Удаляем %%~nxF из %source%
        del "%%F"
    )
)
```
Выводит сообщение о том, что синхронизация файлов завершена.
```
echo Синхронизация завершена.
```
Завершает локальный контекст переменных, возвращая все переменные к их предыдущим значениям (если они были установлены до вызова setlocal).
```
endlocal
```
## Bash файл
- ### Код программы :computer:
```bash
#!/bin/bash

if [ ! -n "$1" ]; then
echo "No parameters found. "
exit 1
fi

if [ ! -n "$2" ]; then
echo "No parameters found. "
exit 1
fi

source=$1
destination=$2

if [ ! -d source ]; then
    echo "Директория-источник $source не существует."
    exit 1
fi

if [ ! -d destination ]; then
    echo "Директория-назначение $destination не существует."
    exit 1
fi

cd destination

for file in *; do
    filename=$(basename "$file")
    echo $filename
    cd -
    cd source
    if [ ! -f $filename ] ; then
        echo "Копируем $filename из $destination в $source"
        cp $destination/$filename $source/$filename
    fi
    cd -
    cd destination
done

cd -
cd source

for file in *; do
    filename=$(basename "$file")
    echo $filename
    cd -
    cd destination
    if [ ! -f $filename ] ; then
        echo "Удаляем $filename из $source"
        cd -
        cd source
        rm $file
    fi
done


```
### Пояснение кода
Указывает, что скрипт должен выполняться с использованием интерпретатора bash.
```
#!/bin/bash
```
Проверяет, передан ли первый аргумент (\$1). Если он пустой, выводит сообщение об ошибке и завершает выполнение скрипта с кодом 1.
```
if [ ! -n "\$1" ]; then
    echo "No parameters found. "
    exit 1
fi
```
Аналогично, проверяет, передан ли второй аргумент (\$2). Если он пустой, выводит сообщение об ошибке и завершает выполнение скрипта с кодом 1.
```
if [ ! -n "\$2" ]; then
    echo "No parameters found. "
    exit 1
fi
```
Присваивает переменным source и destination значения, переданные как аргументы.
```
source=\$1
destination=\$2
```
Проверяет, существует ли директория, указанная в переменной source. Если нет, выводит сообщение об ошибке и завершает выполнение скрипта с кодом 1.
```
if [ ! -d source ]; then
    echo "Директория-источник $source не существует."
    exit 1
fi
```
Аналогично, проверяет, существует ли директория, указанная в переменной destination. Если нет, выводит сообщение об ошибке и завершает выполнение скрипта с кодом 1.
```
if [ ! -d destination ]; then
    echo "Директория-назначение $destination не существует."
    exit 1
fi
```
Переходит в директорию-назначение.
```
cd destination
```
Цикл for, который проходит по всем файлам в директории-назначении:
filename=$(basename "$file") извлекает имя файла из полного пути.
cd - возвращается в предыдущую директорию (в данном случае, это директория, из которой был вызван скрипт).
cd source переходит в директорию-источник.
if [ ! -f $filename ] проверяет, существует ли файл с таким именем в директории-источнике.
Если файл не существует, выводится сообщение о копировании, и файл копируется из директории-назначения в директорию-источник.
Затем снова происходит переход в директорию-назначение.
```
for file in *; do
    filename=$(basename "$file")
    echo $filename
    cd -
    cd source
    if [ ! -f $filename ] ; then
        echo "Копируем $filename из $destination в $source"
        cp $destination/$filename $source/$filename
    fi
    cd -
    cd destination
done
```
Возвращается в предыдущую директорию и затем переходит в директорию-источник.
```
cd -
cd source
```
Цикл for, который проходит по всем файлам в директории-источнике:
filename=$(basename "$file") извлекает имя файла.
cd - возвращается в предыдущую директорию (в данном случае, это директория, из которой был вызван скрипт).
cd destination переходит в директорию-назначение.
if [ ! -f $filename ] проверяет, существует ли файл с таким именем в директории-назначении.
Если файл не существует, выводится сообщение о том, что файл будет удален из директории-источника, и файл удаляется с помощью команды rm.
```
for file in *; do
    filename=$(basename "$file")
    echo $filename
    cd -
    cd destination
    if [ ! -f $filename ] ; then
        echo "Удаляем $filename из $source"
        cd -
        cd source
        rm $file
    fi
done
```
### Выводы: 
 В ходе выполнения лабораторной работы по освоению командных оболочек cmd (для операционных систем семейства MS Windows) и shell (для операционных систем семейства Unix) были получены практические навыки работы с консольными программами и командами в различных операционных системах. 
