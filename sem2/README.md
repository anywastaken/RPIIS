# Лабораторная работа №1

## Цели:

* Выполнить свой вариант работы; 
* Реализовать решение варианта на высокоуровневом ЯП (у меня это C++).

## Вариант: 
Для выполнения работы был выдан вариант **21** "Система непересекающихся множеств. Создание множества. Объединение двух множеств. Определение множества, которому принадлежит заданный элемент".

## Реализация:

Для начала был создан хедер-файл **Dsu.h**, в котором был инициализирован класс **Dsu**, в котором лежали все основные функции для последующей работы:

```class Dsu
{
private:
    vector <int> parent; // хранит родителя
    vector <int> rank; // ранг каждого элемента
public:
    Dsu(int size);// конструктор
    int find(int x); //поиск элемента
    //объединение
    void unite_two_sets(int x, int y);
    //указанный элемент
    int get_set(int x);

    int size() const;


};
```

В файле **Dsu.cpp** была реализована работа функций из **Dsu.h**:

```Dsu::Dsu(int size)
{
    parent.resize(size);
    rank.resize(size, 0);
    for (int i = 0; i < size; i++)
    {
        parent[i] = i;
    }
}


Данная функция инициализирует векторы parent и rank, где parent[i] указывает на родителя элемента i. Изначально каждый элемент является своим собственным родителем, rank используется для оптимизации объединения множеств, чтобы избежать глубоких деревьев.

```int Dsu::find(int x) // нахождение корня
{
    if (parent[x] != x)
    {
        parent[x] = find(parent[x]);
    }
    return parent[x];
}
``` 

Ищет корень множества, к которому принадлежит элемент x. Если x не является своим родителем, метод рекурсивно вызывает find для его родителя. Применяется техника "сжатия путей" (path compression), которая делает последующие запросы более эффективными, обновляя родителя элемента x на корень.

```void Dsu::unite_two_sets(int x, int y)
{
    int root_x = find(x);
    int root_y = find(y);

    if (root_x != root_y)
    {
        if (rank[root_x] < rank[root_y])
        {
            parent[root_x] = root_y;
        }
        else if (rank[root_x] > rank[root_y])
        {
            parent[root_y] = root_x;
        }
        else
        {
            parent[root_y] = root_x;
            rank[root_x]++;
        }
    }
}
```

Объединяет два множества, содержащие элементы x и y, находит корни обоих элементов.
Если корни различны, сравнивает их ранги:
* Если ранг одного меньше, родитель этого элемента устанавливается на другой.
* Если ранг больше, происходит обратное.
Если ранги равны, один множества становится родителем другого, а ранг одного из них увеличивается.

Вывод: в данной лабораторной работе была разработана библиотека для работы с системой непересекающихся множеств, а также реализованы основные функции для этой библиотеки.

Источники:

Вся необходимая информация была найдена [здесь](https://ru.algorithmica.org/cs/set-structures/dsu/), [здесь](https://brestprog.by/topics/dsu/), и [здесь](https://www.google.com/).
