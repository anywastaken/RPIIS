# Лабораторная работа №1
**Вариант №22** (Очередь. Вставка элемента в очередь. Взятие элемента из очереди).

## Цели лабораторной работы:
1. Разработать библиотеку для работы с очередью  на выбранном языке программирования (например, C/C++, Java, Python).
2. Создать тестовую программу для демонстрации функциональности разработанной библиотеки.
3. Обеспечить обработку некорректных данных, предусмотрев корректное завершение программы при возникновении ошибок.
4. Составить отчет по выполнению лабораторной работы.
   
## Задачи лабораторной работы
1. Изучить спецификацию задачи по работе с множествами.
2. Выбрать язык программирования для реализации библиотеки (например, C++, Java, Python) в соответствии с индивидуальным заданием.
3. Разработать и реализовать библиотеку для работы с элементами, включая операции вставки и удаления элементов.
4. Написать тестовую программу, которая демонстрирует основные сценарии использования библиотеки.
5. Провести тестирование разработанной библиотеки, убедившись в ее правильной работе на различных входных данных.
6. Составить подробный отчет, включая описание решения задачи, архитектуру библиотеки, результаты тестирования и выводы.

## Список используемых понятий:
**Очередь** – линейный список, в котором извлечение данных происходит из начала, а добавление – в конец, т. е. это структура, организованная по принципу FIFO (First In, First Out) – первым вошел, первым выйдет.
**Рекурсия** - метод программирования, при котором функция вызывает сама себя для решения подзадачи.

## Описание используемых алгоритмов:

1. **Алгоритм добавления/вставки элемента**
   
   Этот алгоритм добавляет элемент в очередь.
```cpp
void dobavqueue(Element*& pervyi, Element*& posled, const string& value) {
    Element* newElement = new Element;
    newElement->data = value;
    newElement->next = nullptr;

    if (posled == nullptr) {
        pervyi = posled = newElement;
    }
    else {
        posled->next = newElement;
        posled = newElement;
    }

    cout << "Элемент '" << value << "' добавлен в очередь." << endl;
}
```

<img src="https://ltdfoto.ru/images/2025/02/19/129c33cddaa474c77.png" alt="  Визуальный пример:" width="400" />

2. **Алгоритм удаления/взятия элемента**   

   Этот алгоритм удаляет первый элемент очереди, если такой имеется. В противном случае ничего не произойдет.
```cpp
string vziatqueue(Element*& pervyi, Element*& posled) {
    if (pervyi == nullptr) {
        cout << "Очередь пуста." << endl;
        return "";
    }

    string value = pervyi->data;

    Element* temp = pervyi;
    pervyi = pervyi->next;

    if (pervyi == nullptr) {
        posled = nullptr;
    }

    delete temp;
    return value;
}
```

<img src="https://ltdfoto.ru/images/2025/02/19/2dcc93482481a3bc1.png" alt="  Визуальный пример:" width="400" />

3. **Алгоритм очистки очереди**
   
   Этот алгоритм очищает очередь, освобождая память, выделенную для каждого элемента.
```cpp
void clearqueue(Element*& pervyi, Element*& posled) {
    while (pervyi != nullptr) {
        Element* temp = pervyi;
        pervyi = pervyi->next;
        delete temp;
    }

    posled = nullptr;

    cout << "Очередь очищена." << endl;
}
```

<img src="https://ltdfoto.ru/images/2025/02/19/44ac9d0b3c5ec61fb.png" alt="  Визуальный пример:" width="400" />
4. **Алгоритм вывода содержимого очереди на экран**
   
   Этот алгоритм выводит содержимое очереди.
```cpp
void viewqueue(Element* pervyi) {
    if (isEmpty(pervyi)) {
        cout << "Очередь пуста." << endl;
        return;
    }

    cout << "Содержимое очереди: ";

    Element* temp = pervyi;
    while (temp != nullptr) {
        cout << temp->data << " ";
        temp = temp->next;
    }

    cout << endl;
}
```
<img src="https://ltdfoto.ru/images/2025/02/19/250e74aa0564efdf2.png" alt="  Визуальный пример:" width="400" />
## Вывод:

В результате выполнения данной работы были получены следующие практические навыки:


-изучение структуры очередь


-умение работать с header-файлами


-изучение базовых алгоритмов для работы со структурами типа очередь

## Используемые источники:
1) **Создание библиотеки** :(https://www.youtube.com/watch?v=pAxEfF2yVlM&t=1s)
