# Задача
Реализовать декартово дерево (Treap) как динамическую структуру данных.Вставка.Поиск.Удаление.Построение дерева из массива значений. Объединение двух деревьев. Пересечение двух деревьев.
## Цель
Исследовать свойства структур данных и разработать
библиотеку алгоритмов обработки структур данных.
## Список ключевых понятий:
`Декартово дерево`- это структура данных, объединяющая в себе бинарное дерево поиска и бинарную кучу.

Более строго, это структура данных, которая хранит пары (X,Y) в виде бинарного дерева таким образом, что она является бинарным деревом поиска по x и бинарной пирамидой по y. Предполагая, что все X и все Y являются различными, получаем, что если некоторый элемент дерева содержит (X0,Y0), то у всех элементов в левом поддереве X < X0, у всех элементов в правом поддереве X > X0, а также и в левом, и в правом поддереве имеем: Y < Y0.
Дерамиды были предложены Сиделем (Siedel) и Арагоном (Aragon) в 1996 г.

**Преимущества такой организации данных**
В том применении, которое мы рассматриваем (мы будем рассматривать дерамиды, поскольку декартово дерево - это фактически более общая структура данных), X'ы являются ключами (и одновременно значениями, хранящимися в структуре данных), а Y'и - называются **приоритетами**. Если бы приоритетов не было, то было бы обычное бинарное дерево поиска по X, и заданному набору X'ов могло бы соответствовать много деревьев, некоторые из которых являются вырожденными (например, в виде цепочки), а потому чрезвычайно медленными (основные операции выполнялись бы за O (N)).

В то же время, **приоритеты** позволяют **однозначно** указать дерево, которое будет построено (разумеется, не зависящее от порядка добавления элементов) (это доказывается соответствующей теоремой). Теперь очевидно, что если **выбирать приоритеты случайно**, то этим мы добьёмся построения **невырожденных** деревьев в среднем случае, что обеспечит асимптотику O (log N) в среднем. Отсюда и понятно ещё одно название этой структуры данных - **рандомизированное бинарное дерево поиска**

**СВОЙСТВА:**
1. Для каждого узла все ключи в левом поддереве меньше ключа узла,а все ключи в правом поддереве больше ключа узла.
2. Для каждого узла приоритет в узле больше приоритетов его потомков.

В данном примере из массива ключей {3,2,1,5,4,7} и случайного приоритета каждого ключа получим дерамиду:
![Treap](232821.png)

**Основные операции `Дерамиды`:**
- *merge*- функция объединения деревьев
- *split* - функция "разрезания" дерева
- *insert* - функция вставки нового узла
- *remove* - функция удаления узла
- *search* - функция поиска узла по узлу(возвращается адрес в памяти)
- *intersection* - функция пересечения двух деревьев
  
 Алгоритм создания декартового дерева состоит в том что, зная ключ, создается уникальных приоритет "этого" ключа.Поэтому наше декартовое дерево единственно в своем роде.

 ## Источники
[youtubchik](https://youtu.be/68mMGJl5F8s?si=EASqeh28jxrc3E0S)
[algoritmichka](https://algorithmica.org/ru/treap)
