## Лабораторная работа №1
### Автор: Захаренков Иван, гр.421702
## Вариант 25. Приоритетная очередь

## Содержание

- [*Глоссарий*](#глоссарий)
- [*Введение*](#введение)
  - [*Цели*](#цели)
  - [*Задачи*](#постановка-задачи)
  - [*Вариант*](#вариант)
- [*Алгоритм*](#алгоритм)
  - [*Возможные реализации*](#возможные-реализации-алгоритма)
    - [*Реализация 1*](#реализация-1)
    - [*Реализация 2*](#реализация-2)
  - [*Реализация алгоритма*](#реализация-алгоритма)
    - [*Построение кучи*](#построение-кучи)
    - [*Вставка элементов*](#вставка-элементов)
    - [*Получение и удаление значения*](#получение-и-удаление-значения)
  - [*Пример работы алгоритма*](#пример-работы-алгоритма)
- [*Вывод*](#вывод)
- [*Список литературы*](#список-литературы)


## Глоссарий

- **Приоритетная очередь (priority queue)** - абстрактный тип данных, похожий на очередь, но где каждый элемент имеет приоритет. Элемент с более высоким приоритетом обслуживается раньше элемента с более низким приоритетом.

- **Дерево (tree)** - иерархическая структура данных, состоящая из узлов, связанных между собой направленными ребрами без циклов, где есть один корневой узел.

- **Бинарное дерево (binary tree)** - дерево, в котором каждый узел имеет не более двух потомков (левый и правый).

- **Куча (heap)** - специализированное бинарное дерево, удовлетворяющее свойству кучи: значение в любом узле не меньше (для макс-кучи) или не больше (для мин-кучи) значений в его дочерних узлах.

- **Структура (struct)** - пользовательский тип данных, объединяющий несколько связанных элементов данных в одну логическую единицу.

- **Класс (class)** - пользовательский тип данных, объединяющий данные и методы их обработки, обеспечивающий инкапсуляцию и другие принципы ООП.

- **Методы (methods)** - функции, являющиеся членами класса или структуры, имеющие доступ к их внутренним данным.

- **Временная сложность (time complexity)** - оценка количества элементарных операций, необходимых для выполнения алгоритма в зависимости от размера входных данных.

- **Шаблоны (templates)** - механизм в C++, позволяющий создавать обобщённый код, работающий с различными типами данных.


## Введение

### Цели

- Исследовать свойства структур данных.
- Разработать удобный инструмент для обработки структур данных.

### Постановка задачи

В ходе лабораторной работы создать header файл, в котором реализовать методы для решения поставленной задачи (варианта).

#### Требования к коду:

- Грамотно именовать элементы кода
- Не использовать глобальные переменные
- Присутствие структур(классов) данных, где декларацию делать в .hpp, а реализацию в .cpp

### Вариант

В данной лабораторной работе представлено решение 25 варианта из [методички](https://drive.google.com/drive/folders/1AyWt3nPYPlhdaGD3Hlfrc33eyXt2OD84).
_Условие_: реализовать структуру данных приоритетной очереди. Реализовать функцию добавления, удаления, просмотра элемента.

## Алгоритм
### Возможные реализации алгоритма

#### Реализация 1

<u>Неоптимальная</u> реализация _"в лоб"_. **Суть** заключается в том, чтобы отсортировать массив, после выдавать наибольший (по приоритету) элемент.

**Временная сложность:**
* Взятия элемента O(1)
* Добавления элемента O(n)
* Удаления элемента O(1)


#### Реализация 2

Оптимальная и быстрая реализация заключается в использовании кучи. **Суть** заключается в том, чтобы хранить элементы в _"узлах"_ по возрастанию приоритета. Т.е. в вершине лежит элемент с максимальным приоритетом. Пример кучи:

![Пример кучи](Images/Heap%20example.png)

**Временная сложность:**
* Взятия элемента O(1)
* Добавления элемента O(log(n))
* Удаления элемента O(log(n))

### Реализация алгоритма

В лабораторной работе использовался [оптимальный](#реализация-2) варант. 

### Построение кучи
Для построения кучи используется 2 функции:
```c++
void heapify(int i) {
        int largest = i;
        int left = 2 * i + 1;
        int right = 2 * i + 2;

        if (left < size && heapArray[left] > heapArray[largest])
            largest = left;

        if (right < size && heapArray[right] > heapArray[largest])
            largest = right;

        if (largest != i) {
            std::swap(heapArray[i], heapArray[largest]);
            heapify(largest);
        }
}
void buildHeap() {
        for (int i = (size - 1) / 2; i >= 0; i--) {
            heapify(i);
        }
}
```
Функция `buildHeap` начинает построение кучи с нижних уровней дерева, а функция `heapify` обеспечивает правильный порядок элементов, перемещая элементы с меньшим приоритетом вниз по дереву для соблюдения свойства максимальной кучи.

### Вставка элементов

В данной библиотеке реализовано несколько вариантов вставки элементов: массив из этих элементов или одиночный элемент. Код:
```c++
void resizeHeap() {
        if (capacity == 0) capacity = 1;
        while (capacity <= size) {
            capacity <<= 1;
        }
        heapArray.resize(capacity);
}
void insert(const std::vector<T>& arr) {
        int oldSize = size;
        size += arr.size();
        resizeHeap();
        for (int i = 0; i < arr.size(); ++i)
            heapArray[oldSize + i] = arr[i];
        buildHeap();
}
void insert(T value) {
        if (capacity == 0) capacity = size;
        if (size >= capacity) {
            resizeHeap();
        }

        size++;
        int i = size - 1;
        heapArray[i] = value;

        while (i != 0 && heapArray[(i - 1) / 2] < heapArray[i]) {
            std::swap(heapArray[i], heapArray[(i - 1) / 2]);
            i = (i - 1) / 2;
        }
    }
```

Функция `resizeHeap` обеспечивает динамическое увеличение размера кучи. Когда количество элементов достигает текущей ёмкости, функция удваивает размер внутреннего массива. Это позволяет эффективно добавлять новые элементы без частого перевыделения памяти.

### Получение и удаление значения

Используются 2 функции:
```c++
T top() {
        if (size <= 0)
            throw std::out_of_range("Empty priority queue");

        return heapArray[0];
}
T pop() {
        if (size <= 0)
            throw std::out_of_range("PriorityQueue is empty");
        T root = heapArray[0];
        heapArray[0] = heapArray[size - 1];
        size--;
        heapify(0);
        return root;
}
```

Функция `top` просто возвращает значение корневого элемента кучи. Функция `pop` не только возвращает корневой элемент, но и удаляет его, после чего восстанавливает структуру кучи: последний элемент перемещается в корень и "просеивается" вниз, меняясь местами с большим из дочерних элементов, пока не окажется на правильной позиции.

## Пример работы алгоритма

Напишем небольшой код для проверки работы кучи:
```c++
#include <iostream>
#include <vector>
#include "PriorityQueue.hpp"

using namespace std;

int main() {

    PriorityQueue<int> pq;
    int n; cin >> n;
    vector<int> arr(n, 0);
    for (int i = 0; i < n; i++) {
     cin >> arr[i];
    }

    pq.insert(arr);

    pq.insert(9);
    cout << "After inserting 9: " << endl;
    cout << "Top value: " << pq.top() << endl;
    cout << "Popped value: " << pq.pop() << endl;

    cout << "Other value: ";
    while (!pq.empty()) {
        cout << pq.top() << ' ';
        pq.pop();
    }

    return 0;
}
```
Ввод: 
```
5
5 2 1 3 4
```

Вывод программы:
```
After inserting 9:
Top value: 9
Popped value: 9
Other value: 5 4 3 2 1
```

## Вывод

В результате выполнения работы удалось:
1. Реализовать приоритетную очередь с методами добавления и изъятия элементов на ЯП С++
2. Изучить способы работы со структурами, типа деревьев
3. Попрактиковаться в работе с классами

Все поставленные цели были достигнуты, а задачи выполнены

## Список литературы

1. https://brestprog.by/topics/heap/
2. https://habr.com/ru/sandbox/199002/
3. https://www.geeksforgeeks.org/cpp-stl-heap/?ysclid=m7jhf79j6h630486325
4. https://ravesli.com/urok-105-stek-i-kucha/?ysclid=m7jhfoj58k935529866
5. https://metanit.com/cpp/tutorial/7.12.php?ysclid=m7jhg8gfeg841882733

![Turlip](https://media1.tenor.com/m/ZNSYAVeaPTQAAAAd/dancing-gif-turnip.gif)