# Лабоаторная работа 1
## Цели: 
*Исследовать свойства структур данных и разработать
библиотеку алгоритмов обработки структур данных*

## Задачи:
*1. Разработать библиотеку для работы со структурой данных, указанной в
индивидуальном задании, на любом императивнойм языке
программирования (Pascal, C\C++, Java, C#, Python и др.)*

*2. Разработать тестовую программу, которая демонстрирует
работоспособность реализованной библиотеки работы со структурой
данных.*

*3. По результатам выполнения задания составить отчет.*

## Вариант: 
*25.Очередь с приоритетом. Вставка элемента в очередь. Взятие элемента
из очереди.*

## Основные понятия:
**Очередь с приоритетом** (англ. priority queue) — абстрактный тип данных в программировании, поддерживающий две обязательные операции — добавить элемент и извлечь максимум (минимум).

**Двоичная куча** (пирамида, сортирующее дерево, binary heap) это полное двоичное дерево, где поддерживается свойство порядка размещения вершин (heap order property) и выполняются следующие условия:
* Сортировка значений: Значение в каждой вершине не меньше, чем значения её потомков. В случае мин-кучи, значение в каждой вершине не больше значений её потомков, в макс-куче — не меньше.

* Балансировка глубины: Разница в глубине листьев (расстояние от корня до листа) не превышает 1 слой. Это обеспечивает сбалансированность дерева и эффективное использование памяти.

* Заполнение слоев слева направо: Последний слой дерева заполняется слева направо, без пропусков. Это обеспечивает эффективное хранение данных в виде массива.

**Операции вставки и извлечения:** 
* Вставка (insert): Операция добавления нового элемента в структуру данных. В контексте приоритетной очереди, элемент вставляется с учетом его приоритета.
  
* Извлечение (extract): Операция удаления и возврата элемента с наивысшим приоритетом из структуры данных.

**Методы используемые в структуре данных:**
* Метод `up(i)`: Поднимает элемент вверх по дереву, обеспечивая корректность структуры данных после вставки.
* Метод `down(i)`: Спускает элемент вниз по дереву, обеспечивая корректность структуры данных после извлечения.

## Алгоритмы операций:
Очередь с приорететом эффективнее всего представлять в виде **бинарной кучи**. Я реализовала бинарную кучу с помощью `std::vector`. Если рассматриваемый элемент имеет индекс i, то индексы правого и левого ребёнка соответственно `2*i+1`, `2*i+2`, а индекс родителя `(i-1)/2`.

![Сортирующее_дерево svg](https://github.com/user-attachments/assets/da4b6392-c3d9-4970-9af0-47843990741d)

![Сортирующее_дерево_развернутое_в_массив svg](https://github.com/user-attachments/assets/1d4fd389-7e53-4ddd-8986-0fe666714875)

**Метод вставки (insert):** Отвечает за вставку нового элемента в приоритетную очередь. Этот метод добавляет элемент в конец вектора и затем вызывает метод **up**, который поднимает элемент вверх по дереву для обеспечения соблюдения условий бинарной кучи.

* **Вспомогательный метод up:** Отвечает за подъем элемента вверх по дереву для восстановления условий бинарной кучи после вставки. Этот метод выполняет цикл, сравнивая значение текущего элемента с его родителем и меняя их местами при необходимости до тех пор, пока элемент не достигнет правильной позиции.

```
void PriorityQueue::insert(int value) {
	a.push_back(value);
	up(a.size() - 1);
}

void PriorityQueue::up(int i) {
	while (a[i] > a[(i - 1) / 2] && i != 0) {
		swap(a[(i - 1) / 2], a[i]);
		i = (i - 1) / 2;
	}
}
```
**Метод извлечения (extract):** Отвечает за извлечение элемента с наивысшим приоритетом из приоритетной очереди. Этот метод извлекает значение из корня, заменяет корень последним элементом вектора, а затем вызывает метод down, который опускает новый корень вниз по дереву для восстановления условий бинарной кучи. Также учитыется случай, когда происходит попытка извлечения из пустой очереди, для этого случая создано исключение `std::out_of_range`.

* **Вспомогательный метод down:** Отвечает за опускание элемента вниз по дереву для восстановления условий бинарной кучи после извлечения. Этот метод выполняет цикл, сравнивая значение текущего элемента с его потомками и меняя его место с наибольшим из потомков, если это необходимо, до тех пор, пока элемент не достигнет правильной позиции.
```
  int PriorityQueue::extract() {
	if (isEmpty()) {
		throw out_of_range("Priority queue is empty");
	}

	int value = a[0];
	a[0] = a[a.size() - 1];
	a.pop_back();
	down(0);
	return value;
}

void PriorityQueue::down(int i) {
	while (2 * i + 1 < a.size()) {
		int maxChild = 2 * i + 1;
		if (maxChild + 1 < a.size() && a[maxChild] < a[maxChild + 1])
			maxChild++;
		if (a[i] >= a[maxChild])
			break;
		swap(a[maxChild],a[i]);
		i = maxChild;
	}
}
```
**Метод проверки пустой очереди (isEmpty):** Проверяет, пуста ли приоритетная очередь. Возвращает true, если вектор a пуст, и false в противном случае.
```
bool priorityQueue::isEmpty() const {
    return a.empty();
}
```
**Инициализация:**

* Создание экземпляра класса PriorityQueue.
* Внутренний вектор a используется для хранения элементов в виде бинарной кучи.

**Вставка элемента:**

* Новый элемент добавляется в конец вектора.
* Вызывается метод up для восстановления условий бинарной кучи.
  
**Извлечение элемента:**

* Проверка наличия элементов в куче.
* Извлечение значения из корня (с наивысшим приоритетом).
* Замена корня последним элементом вектора.
* Вызов метода `down` для восстановления условий бинарной кучи.

**Подъем элемента вверх:**

Пока текущий элемент больше родителя и не достигнут корень:
* Меняем местами текущий элемент и его родителя.
* Обновляем индекс текущего элемента.

**Опускание элемента вниз:**

Пока есть хотя бы один потомок текущего элемента:
* Выбираем максимального из потомков.
* Если текущий элемент меньше выбранного потомка, меняем их местами.
* Обновляем индекс текущего элемента.

**Проверка наличия элементов:**

Проверка, пуста ли куча, основываясь на пустоте вектора a.

## Тестовая программа:

Данная программа проверяет работу функций, созданной библиотеки.
```
#include <iostream>
#include <Windows.h>
#include "PriorityQueue.h"

void showMenu() {
    std::cout << "1. Вставить элемент в приоритетную очередь\n";
    std::cout << "2. Извлечь элемент с высоким приоритетом\n";
    std::cout << "3. Проверить, пуста ли очередь\n";
    std::cout << "4. Выйти\n";
}

int main() {
    setlocale(0, "rus");
    priorityQueue pq;
    int choice, value;

    while (true) {
        showMenu();
        std::cout << "Введите номер действия: ";
        std::cin >> choice;

        switch (choice) {
        case 1:
            std::cout << "Введите значение для вставки: ";
            std::cin >> value;
            pq.insert(value);
            std::cout << "Элемент " << value << " вставлен.\n";
            break;
        case 2:
            try {
                value = pq.extract();
                std::cout << "Извлеченный элемент: " << value << "\n";
            }
            catch (const std::out_of_range& e) {
                std::cout << e.what() << "\n";
            }
            break;
        case 3:
            if (pq.isEmpty()) {
                std::cout << "Очередь пуста.\n";
            }
            else {
                std::cout << "В очереди есть элементы.\n";
            }
            break;
        case 4:
            std::cout << "Выход из программы.\n";
            return 0;
        default:
            std::cout << "Некорректный выбор. Попробуйте снова.\n";
        }
    }

    return 0;
}
```
## Выводы:
В результате выполнения лабораторной работы были получены знания в области принципов работы приоритетных очередей, основанных на max-heap. Освоена методика "подъема" и "опускания" элементов, что позволило эффективно управлять структурой данных с максимальным элементом в корне. Также приобретены навыки применения стандартных контейнеров C++, в частности, использование std::vector для представления бинарной кучи.

Реализована библиотека для приоритетной очереди, включающая грамотные операции вставки, извлечения и проверки на пустоту, обеспечив эффективность и корректность работы структуры данных. Написана тестовая программа, что позволило убедиться в надежности и правильности реализации.

## Используемые источники:
Очередь с приорететом, алгоритмы [https://dementiy.gitbooks.io/algo/content/heaps.html]

Очередь с приорететом, Википедия [(https://ru.wikipedia.org/wiki/Очередь_с_приоритетом_(программирование))]

Реализация бинарной кучи [https://habr.com/ru/articles/112222/]

Реализация очереди с приоритетом на с++ [https://www.youtube.com/watch?v=o1ZDXf7NGN4&t=868s]
