# Лабораторная работа 1

## Тема работы

Тема работы: Структуры данных

## Цель работы

Цель работы: Исследовать свойства структур данных и разработать библиотеку алгоритмов обработки конкретной структуры данных.

## Задача

Задача ЛР:

1. Разработать библиотеку для работы со структурой данных, указанной в индивидуальном задании, на любом императивном языке программирования (Pascal, C\C++, Java, C#, Python и др.)
2. Мною выполнен вариант 12, структура данных и задание : Таблица Юнга. Вставка элемента в таблицу. Удаление элемента из таблицы.
3. Разработать тестовую программу, которая демонстрирует
работоспособность реализованной библиотеки работы со структурой
данных.
4. Разработать систему тестов, которые продемонстрировали бы
работоспособность реализованной библиотеки. Система тестов должна
отвечать требованиям полноты, адекватности и непротиворечивости.
Система тестов должна учитывать не только корректную работу на
правильных данных, но и предусматривать корректное завершение
программы в случае некорректных данных.
5. По результатам выполнения задания составить отчет.

## Cписок используемых понятий

**Диаграмма Юнга** формы (nl, n2,..., nM), где n1 &ge; n2 &ge; ... &ge; nМ &ge; 0 — это расположение n1 + n2 + ... + nМ *различных* целых чисел в массиве строк, выровненных по левому краю, где в I-й строке содержится nI элементов; при этом в каждой строке элементы возрастают слева направо, а элементы каждого столбца возрастают сверху вниз. 

Пример:

|         |         |         |         |         |         |
|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|
| 1       | 2       | 5       | 9       | 10      | 15      | 
| 3       | 6       | 7       | 13      |
| 4       | 8       | 12      | 14      |
| 11      |         |         |         |

Это диаграмма формы (6,4,4,1). **Форма** - число элементов в каждой строке таблицы.

## Описание алгоритмов

Для тестирования и отслеживания ошибок был создан класс:

```C++
enum class ResultCode
    {
        Success,
        DublicateError,
        WrongTableError,
        WrongPositionToDeleteError
    };
```

### Вставка элемента в таблицу

Рассмотрим алгоритм вставки элемента в диаграмму. Пусть Р — диаграмма из целых положительных чисел, х — целое положительное число, не содержащееся в Р. Этот алгоритм преобразует Р в другую диаграмму, содержащую х наряду с исходными элементами Р. Новая диаграмма будет иметь ту же форму что и старая, с той лишь разницей, что на пересечении строки S и столбца T появится новый элемент, где S и T формируются в процессе выполнения алгоритма.

Алгоритм для i-й строки: если она пуста, то ставим элемент в позицию (i, 0) (S = i, Т = 0); если элемент х больше всех элементов строки i, то ставим его за последним элементом ``P.Table[i].push_back(x)`` (S = i, Т = ni) (здесь ni — количество элементов в i-той строке). Если найдено такое j, что P(i, j) < х < P(i, j + 1), то обмениваем значения х и P(i,j + 1): ``swap(x,P.Table[i][j])`` и переходим к следующей строке.

В моей программе это реализовано так:

```C++
ResultCode YoungTable::AddToTable(YoungDiagram::YoungTable &P, int x) {
        if (CheckDublicate(x, P) == false) { // проверка на добавление дубликата
            //std::cout << "Error, Element must not be repeated with existing ones.\n";
            return ResultCode::DublicateError;
        }
        if(CheckTable(P) == false) { // проверка на корректность таблицы
            //std::cout<<"Error, this is not a Young table.\n";
            return ResultCode::WrongTableError;
        }
        for (int i = 0; i < P.Table.size(); i++) {
            if (P.Table[i].empty() == true) { // если строка пуста, то ставим элемент в позицию (i, 0)
                P.Table[i].push_back(x);
                return ResultCode::Success;
                break;
            }
            bool isGreater = true;
            for (int j = 0; j < P.Table[i].size(); j++) {
                if (x < P.Table[i][j]) { // Если найдено такое j, что P(i, j) < х < P(i, j + 1), то обмениваем значения х и P(i,j + 1) и переходим к следующей строке
                    std::swap(x, P.Table[i][j]);
                    isGreater = false;
                    if (i == P.Table.size() - 1) {
                        P.Table.push_back({});
                    }
                    break;
                }
            }
            if (isGreater == true) { // если элемент х больше всех элементов строки i, то ставим его за последним элементом
                P.Table[i].push_back(x); 
                return ResultCode::Success;
                break;
            }
        }
        if (P.Table.size() == 0) { // если таблица пуста то просто вставляем строку вместе с первым эл-том
            P.Table.push_back({x});
            return ResultCode::Success;
        }

    }
```

### Удаление элемента из таблицы

Алгоритм удаления элемента из диаграммы по заданным S и Т (строка и столбец соответственно) удалит элемент с «крайней» позиции диаграммы (S, Т) (в диаграмме нет элементов ниже и правее этой позиции); при этом переменная х получит значение удаленного элемента (всегда из первой строки). 

Неформально этот алгоритм может быть описан следующим образом: берем элемент из позиции диаграммы с координатами (S, Т) и заносим его значение в `х`. Далее для всех строк с номерами i от `S-1` до `0` находим элемент (на позиции j), такой что `P(i, j) < х < P(i, j + 1)`. Если такого нет, то используем крайний элемент строки в качестве элемента P(i,j). Обмениваем значениями найденный элемент `P(i, j)` и `x` затем переходим к предыдущей строке `(i - 1)`. Элемент, вытесненный из первой строки, и есть результат выполнения алгоритма наряду с перестроенной диаграммой.

В моей программе это реализовано так:

```C++
ResultCode YoungTable::DeleteFromTable(YoungDiagram::YoungTable &P, int s, int t) {
        s--;
        t--; // приводим в удобный вид начальные координаты
        if (CheckExtremePositions(s, t, P) == false) { .// проверка на корректность координат
            //std::cout << "Error, You can delete only from extreme positions\n";
            return ResultCode::WrongPositionToDeleteError;
        }
        if(CheckTable(P) == false) { // проверка на корректность таблицы
            //std::cout<<"Error, this is not a Young table.\n";
            return ResultCode::WrongTableError;
        }
        int x = P.Table[s][t];
        P.Table[s].erase(P.Table[s].begin() + t); // удаляем ячейку с введенными координатами
        if(P.Table[s].empty() == true){
            P.Table.erase(P.Table.begin() + s); // если осталась свободная строка то удаляем и строку 
        }
        for (int i = s - 1; i > -1; i--) {
            bool swapped = false;
            for (int j = 0; j < P.Table[i].size() - 1; j++) {
                if (x > P.Table[i][j] && x < P.Table[i][j + 1]) { // если находим элемент, такой что P(i, j) < х < P(i, j + 1) то обмениваем его с x и переходим к сл. строке
                    swapped = true;
                    std::swap(x, P.Table[i][j]);
                    break;
                }
            }
            if (swapped == false) {
                std::swap(x, P.Table[i][P.Table[i].size() - 1]); // если не нашли нужный то обмениваем x с последним
            }
        }
        return ResultCode::Success;
    }
```

### Использованные источники:

- Долинский М. С. Д64 Решение сложных и олимпиадных задач по программированию: Учебное пособие. — СПб.: Питер, 2006. — 366 с. (Глава 6: Диаграмма Юнга)

## Тестирование библиотеки

### Тестирование добавления в таблицу ###

- #### Тест 1 ####

    Входные данные:
  
      {}
      3
      4
      9
    Выходные данные:
  
      {3, 4, 9}

  В пустую таблицу по очереди добавляются 3, 4 и 9 в таком же порядке.

- #### Тест 2 ####

    Входные данные:
  
      {3, 4, 9}
      2
      5
      1
  
    Выходные данные:
  
      {1, 4, 5},
      {2, 9},
      {3}

- #### Тест 3 ####

    Входные данные:
  
      {1, 2, 9},
      {3, 4},
      {5}
      8
      7
      6
  
    Выходные данные:
  
      {1, 2, 6},
      {3, 4, 7},
      {5, 8},
      {9}

- #### Тест 4 ####

    Входные данные:
  
      {3, 4, 9},
      {1, 2}
      6
  
    Выходные данные:
  
      WrongTableError

  Ошибка, т.к. строки и столбцы таблицы должны быть отсортированы по возрастанию.

- #### Тест 5 ####

    Входные данные:
  
      {1, 2, 9},
      {3, 3}
      6
  
    Выходные данные:
  
      WrongTableError

  Ошибка, т.к. в таблице не должно быть повторов.

- #### Тест 6 ####

    Входные данные:
  
      {1, 2},
      {3, 4, 5, 6},
      {7}
      9
  
    Выходные данные:
  
      WrongTableError

  Ошибка, т.к. в каждой строке таблицы элементов должно быть **не больше**, чем в предыдущей.

- #### Тест 7 ####

    Входные данные:
  
      {1, 2, 9},
      {3, 4}
      9
  
    Выходные данные:
  
      DublicateError

  Ошибка, т.к. нельзя добавить дубликат в таблицу. Все эл-ты таблицы различны.

### Тестирование удаления из таблицы ###

- #### Тест 8 ####

    Входные данные:
  
      {1, 4, 5},
      {2, 9},
      {3}
      3 1
  
    Выходные данные:
  
      {2, 4, 5},
      {3, 9}

Всё верно, т.к. необходимо удалить 3-ю строку, далее 3 поставить на место 2, и далее 2 поставить на место единицы. Получим, что 1 - "вытесненный" элемент.

- #### Тест 9 ####

    Входные данные:
  
      {1, 4, 5},
      {2, 9},
      {3}
      2 2
  
    Выходные данные:
  
      {1, 4, 9},
      {2},
      {3}

- #### Тест 10 ####

    Входные данные:
  
      {1, 4, 5},
      {2, 9},
      {3}
      1 3
  
    Выходные данные:
  
      {1, 4},
      {2, 9},
      {3}

- #### Тест 11 ####

    Входные данные:
  
      {1, 4, 5},
      {2, 9},
      {3}
      1 2
  
    Выходные данные:
  
      WrongPositionToDeleteError

Ошибка, т.к. 1 2 не является "крайней" позицией таблицы.

- #### Тест 12 ####

    Входные данные:
  
      {1, 4, 2},
      {5, 9},
      {7}
      1 3
  
    Выходные данные:
  
      WrongTableError

Ошибка, т.к. строки и столбцы таблицы должны быть отсортированы по возрастанию.

Все тесты были успешно выполнены программой, она выполнила операции верно, и было предусмотрено завершение программы в случае неверных исходных данных, что также сработало верно.

Вывод программы для тестирования:

```GoogleTest
[==========] Running 12 tests from 2 test suites.
[----------] Global test environment set-up.
[----------] 7 tests from AddingTest
[ RUN      ] AddingTest.DefaultTest1
[       OK ] AddingTest.DefaultTest1 (0 ms)
[ RUN      ] AddingTest.DefaultTest2
[       OK ] AddingTest.DefaultTest2 (0 ms)
[ RUN      ] AddingTest.DefaultTest3
[       OK ] AddingTest.DefaultTest3 (0 ms)
[ RUN      ] AddingTest.WrongOrderTest
[       OK ] AddingTest.WrongOrderTest (0 ms)
[ RUN      ] AddingTest.DublicateInTableTest
[       OK ] AddingTest.DublicateInTableTest (0 ms)
[ RUN      ] AddingTest.WrongFormTest
[       OK ] AddingTest.WrongFormTest (0 ms)
[ RUN      ] AddingTest.AddingDublicateTest
[       OK ] AddingTest.AddingDublicateTest (0 ms)
[----------] 7 tests from AddingTest (11 ms total)

[----------] 5 tests from DeleteTest
[ RUN      ] DeleteTest.DefaultDeleteTest1
[       OK ] DeleteTest.DefaultDeleteTest1 (0 ms)
[ RUN      ] DeleteTest.DefaultDeleteTest2
[       OK ] DeleteTest.DefaultDeleteTest2 (0 ms)
[ RUN      ] DeleteTest.DefaultDeleteTest3
[       OK ] DeleteTest.DefaultDeleteTest3 (0 ms)
[ RUN      ] DeleteTest.WrongPositionTest
[       OK ] DeleteTest.WrongPositionTest (0 ms)
[ RUN      ] DeleteTest.WrongTableTest
[       OK ] DeleteTest.WrongTableTest (0 ms)
[----------] 5 tests from DeleteTest (12 ms total)

[----------] Global test environment tear-down
[==========] 12 tests from 2 test suites ran. (32 ms total)
[  PASSED  ] 12 tests.

Process finished with exit code 0
```
  
## Выводы

В ходе выполенния лабораторной работы я:

- Узнал о такой структуре данных как таблица Юнга
- Исследовал её свойства
- Разработал библиотеку алгоритмов для выполнения операций добавления и удаления элемента из таблицы Юнга
- Разработал программу для тестирования библиотеки с использованием GoogleTest
-  Разработал систему тестов, которые продемонстрировали работоспособность реализованной библиотеки. Система тестов отвечает требованиям полноты, адекватности и непротиворечивости. Система тестов учитывает не только корректную работу на правильных данных, но и предусматривает корректное завершение программы в случае некорректных данных.
- Составил отчёт по выполнению работы
