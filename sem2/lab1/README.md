# Лабораторная работа №1
**Вариант №25**

*Очередь с приоритетом. Вставка элемента в очередь. Взятие элемента из очереди.*
## Цель работы:
1. Разработать библиотеку для работы со структурой данных, указанной в индивидуальном задании, на c++.
2. Разработать тестовую программу, которая демонстрирует работоспособность реализованной библиотеки работы со структурой данных.
3. Разработать систему тестов, которые продемонстрировали бы работоспособность реализованной библиотеки. Система тестов должна учитывать не только корректную работу, но и предусматривать корректное завершение
программы в случае некорректных данных.
4. По результатам выполнения задания составить отчет.
## Список использованных понятий
**Очередь с приоритетом** — разновидность очередей, в которой у каждого элемента есть свой приоритет. Обслуживаются они в соответствии со своими приоритетом. Если у элементов одинаковый приоритет, то обслуживаются они по их порядку в очереди.

Обычная очередь подчиняется принципу FIFO «первый вошел — первый вышел». В очередях с приоритетом элементы удаляются в соответствии с их приоритетом. То есть, элемент с самым высоким приоритетом удаляется из очереди в первую очередь.

**Реализация очереди с приоритетом:**

Очереди с приоритетом можно реализовать с помощью следующих структур данных: массив, связный список, куча и двоичное дерево поиска. В данной лабораторной работе я реализовала очередь с помощью отсортированного списка.
## Описание использованных алгоритмов:
**Функция вставления элемента в очередь:**
```cpp
Node* insert(Node* begin, int number, int priority) {
	Node* newNode = new Node; //правильно выделяем память
	newNode->number = number;  // инициализируем поля
	newNode->priority = priority;
	if (begin == NULL || begin->priority < priority) { //меняем вершину списка
		newNode->next = begin;//меняем указатель
		return newNode;// новая вершина списка с более высоким приоритетом
	}
	else { //просто вставляем в список
		Node* t = begin; //временный указатель на вершину списка
		//Ищем позицию для нового узла
		while (t->next != NULL && t->next->priority >= priority) {
			t = t->next;
		}
		newNode->next = t->next;
		t->next = newNode;
	}
	return begin;
}
```
**Функция просмотра очереди:**
```cpp
void View(Node* begin) {
	Node* t = begin;
	while (t != NULL) {
		cout << "Элемент (его приоритет) : " << t->number << " (" << t->priority << ") " << endl;
		t = t->next;
	}
}
```
**Функция удаления элемента:**
```cpp
Node* remove(Node* begin) {
	if (begin == NULL) {
		cout << "Очередь пуста!" << endl;
		return NULL;
	}
	Node* temp = begin;
	begin = begin->next;//перемещаем указатель на следующий элемент
	int number = temp->number;
	int priority = temp->priority;
	delete temp;
	cout << "Удаленный элемент (его приоритет) : " << number << " (" << priority << ") " << endl;
	return begin;
}
```
## Вывод:
В результате выполнения данной работы были получены следующие практические навыки:
1. Изучение типа данных очередь с приоритетом.
2. Работа с header-файлами.
3. Изучение базовых алгоритмов для работы со структурами типа очередь с приоритетом.
## Использованные источники:
1. [Работа с header-файлами](https://www.youtube.com/watch?v=pAxEfF2yVlM)

2. [Алгоритмы для работы со структурами типа очередь с приоритетом](https://codechick.io/tutorials/dsa/dsa-priority-queue)
