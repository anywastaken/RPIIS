# Лабораторная работа №1

# :dart: Цель
Исследовать свойства структур данных и разработать библиотеку алгоритмов обработки конкретной структуры данных.

# :pushpin: Постановка задачи
1. Разработать библиотеку для работы со структурой данных Бор на языке С++.
2. Разработать тестовую программу, которая демонстрирует
работоспособность реализованной библиотеки работы со структурой
данных.
3. Разработать систему тестов, которые продемонстрировали бы работоспособность реализованной библиотеки. Система тестов должна
отвечать требованиям полноты, адекватности и непротиворечивости. Система тестов должна учитывать не только корректную работу на
правильных данных, но и предусматривать корректное завершение программы в случае некорректных данных.
4. По результатам выполнения задания составить отчет.

# :page_with_curl: Задача(Вариант 10)
Организовать структуру данных бор (префиксного дерева), организовать функции вставки строки в бор, удаления строки из бора, поиска строки в
боре.

# :book: Список используемых понятий
*Бор* — структура данных для хранения набора строк, представляющая из себя подвешенное дерево с символами на рёбрах. Строки получаются последовательной записью всех символов, хранящихся на рёбрах между корнем бора и терминальной вершиной.

Например, бор для набора образцов {he,she,his,hers} выглядит так:

![Бор](https://github.com/user-attachments/assets/7f523205-380d-4fba-a12f-32de1f6fd7ac)

В боре, изображённом ниже, хранятся следующие строки:
* “to” - 7 экземпляров
* “tea” - 3 экземпляра
* “ted” - 4 экземпляра
* “ten” - 12 экземпляров
* “A” - 15 экземпляров
* “i” - 11 экземпляров
* “in” - 5 экземпляров
* “inn” - 9 экземпляров

![image](https://github.com/user-attachments/assets/94b18b01-5ecb-4e13-af3e-4e2e1895a7f8)

Таким образом, в каждой вершине бора хранится количество строк, заканчивающихся в этой вершине, и указатели на дочерние вершины, каждая из которых соответствует определённому символу.

Он устроен в виде дерева, где на ребрах между вершинами написана символы, а некоторые вершины помечены терминальными. 
*Терминальные вершины* - вершины обозначающие конец строки.
Бор хранит ровно те строки, которые получаются, если выписать подряд все буквы на путях от корня до терминальных вершин.

Бор также называют *префиксным деревом*. Каждая вершина бора соответствует префиксу, некоторой добавленной строки. Сам это префикс получается путем последовательной записи символов на ребрах на пути от корня до этой вершины. 
При этом, каждому существующему префиксу соответствует ровно одна вершина. *Корень бора* соответствует пустой строке.

# :mag: Описание программы
Решение поставленной задачи реализации библиотеки для работы со структурой данных бор было реализовано с использованием ООП и классов. Проект представляет собой 3 исходных файла: Node.cpp, mainn.cpp, bor.cpp - и 2 заголовочных файла: node.h, bor.h. 

*Файлы заголовков* — это файлы, которые содержат объявления функций, классов, переменных и других элементов, которые могут быть использованы в нескольких исходных файлах. Они обычно имеют расширение .h . Заголовочные файлы помогают структурировать код, разделяя объявления и определения. Это делает код более читаемым и управляемым. Заголовочные файлы позволяют повторно использовать код в разных частях программы или в разных проектах.


Для начала рассмотрим первый заголовочный файл **node.h**, код выглядит таким образом:
-
```
#pragma once
#include <iostream>
#include <vector>
using namespace std;

class Node //класс для хранения символов и указателей на другие узлы
{
public:
	vector<Node*> front_ptrs = { nullptr };
	Node* back_ptr;
	char c;
	int num = 0;
	bool is_root = false;
	bool terminal = false;

	Node();
	Node(char c);
	Node(Node* p);
}
```
Создаем класс Node для хранения символов и указателей на другие узлы. Здесь объявляем front_ptrs вектор указателей на объекты типа Node , инициализируя с одним элементом nullptr. Он будет хранить указатели на предыдущие узлы, связанные с текущим. Также объявляем указатель на объект back_ptr, который будет хранить ссылки на задние узлы. Булевые переменные is_root - будем использоватьь для проверки является ли данный узел вершиной бора, terminal - является ли терминальной(см. список понятий). Далее объявляем конструкторы, которые будут вызываться при создании объекта класса без параметров, или принимающий символ или указатель(для создания узла, который ссылается на другой узел).

Далее рассмотрим файл Node.cpp (описание класса узла). Он содержит реализации методов класса Node, определенного в заголовочном файле node.h.
-
```
#include "Node.h"
#include <iostream>
#include <vector>

Node::Node(){
	is_root = true;
}
Node::Node(char c){
	this->c = c;
}
Node::Node(Node* p){
	this->front_ptrs[0] = p;
}
```
*Конструктор* - это метод, который вызывается во время создания класса. Методы - это обычные функции, в функционале которых можно использовать свойства. Свойства - это все что может хранить информацию, которую вы потом можете заполнять (переменные, массивы и т.д.).
Сначала реализуем конструкторы для класса Node. 
1. Когда создается объект Node без параметров, первый меняет переменную is_root в true (значит, этот узел является корнем бора).
2. При создании объекта Node с одним параметром типа char, этот конструктор устанавливает значение переменной c в переданное значение.
3. Этот конструктор устанавливает первый элемент вектора front_ptrs в переданный указатель p. Это делается для создания узла, который ссылается на другой узел для их связи в боре.

Следующий заголовочный файл - bor.h.
-
```
#pragma once
#include "Node.h"
#include <string>
using namespace std;

void add_string(string, Node*);

int delete_string(string s, Node* root);

void recursive(Node* current, string word);

void view_bor(Node* root);

int search_string(string s, Node* root);

void delete_bor(Node*);
```
Файл содержит объявления функций, которые работают с бором, они позволяют добавлять, удалять, искать строки и выводить содержимое бора.

Далее рассмотрим bor.cpp, который содержит в себе эти функции
-
Каждую рассмотрим отдельно. Алгоритм описан в комментариях.

### Добавление строки в бор
```
void add_string(string s, Node* root){ 
	Node* current = root; //указатель на текущий узел, начинаем с корня бора
	Node* ptr; //указатель для перебора дочерних узлов
	bool find; //переменная, показывающая, найден ли узел с соответствующим символом
	for (int i = 0; i < s.size(); i++){ //обходим строку
		find = false;
		for (int j = 0; j < current->front_ptrs.size(); j++){ //обходим указатели текущего узла
			ptr = current->front_ptrs[j]; // указывает на текущий дочерний узел
			if (ptr != nullptr){
				if (s[i] == ptr->c){ //если среди потомков найден узел, содержащий текущий символ строки, просто переходим на него 
					current = current->front_ptrs[j]; //обновляем указатель current на найденный узел
					find = true;
					break;
				}
			}
		}
		if (find == false){ //если не найден, создаём новый узел
			if (current->front_ptrs[0] == nullptr) //если нет дочерних узлов
				current->front_ptrs[current->num] = new Node(s[i]); //создаем новый узел с символом s[i] и помещаем его в front_ptrs по индексу current->num
			else
				current->front_ptrs.push_back(new Node(s[i])); //добавляем новый узел в конец front_ptrs
			current->num++; //увеличиваем количество дочерних узлов
			ptr = current->front_ptrs[current->num - 1];//указатель ptr указывает на добавленный узел
			ptr->back_ptr = current;
			current = current->front_ptrs[current->num - 1];
		}
		if (i == s.size() - 1)//если дошли до конца строки, делаем текущую вершину терминальной
			current->terminal = true;
	}
	cout << "Строка была добавлена!" << endl << endl;
}
```

### Удаление строки из бора
```
int delete_string(string s, Node* root){
	Node* current = root;
	Node* ptr; //указатель для перебора дочерних узлов
	bool find = false; //переменная, показывающая, найден ли узел с соответствующим символом
	for (int i = 0; i < s.size(); i++){ //обходим строку
		for (int j = 0; j < current->front_ptrs.size(); j++){ //обходим указатели текущего узла
			ptr = current->front_ptrs[j]; //устанавливаем указатель ptr на текущий дочерний узел
			if (ptr == nullptr){
				cout << "Строка не найдена" << endl << endl;
				return 1;
			}
			if (s[i] == ptr->c){ //если символ совпадает с символом текущего узла
				current = current->front_ptrs[j]; //перемещаем указатель current на дочерний узел, соответствующий найденному символу.
				find = true;
				break;
			}
		}
		if (find == false){
			cout << "Строка не найдена" << endl << endl;
			return 1;
		}
	}
	if (current->terminal != true){ //если узел с последним символом строки не помечен как конец слова, пишем, что строки в боре нет, завершаем функцию
		cout << "Строка не найдена" << endl << endl;
		return 1;
	}
	for (int i = s.size() - 1; i >= 0; i--){ //обходим строку с конца
		if ((current->num < 1 && current->terminal == false) || (i == s.size() - 1 && current->num < 1)){ //если текущий узел не имеет потомков кроме раннее удалённого и не является концом другого слова или если это последний символ строки и не имеет больше потомков, то удаляем его
			current = current->back_ptr; //переходим на родительский узел
			for (int j = 0; j < current->front_ptrs.size(); j++){ //ищем среди потомков узел, интересующий нас, удаляем его и указатель, указывавший на него из вектора
				ptr = current->front_ptrs[j];
				if (s[i] == ptr->c){
					delete current->front_ptrs[j];
					current->front_ptrs.erase(current->front_ptrs.begin() + j);//удаляем указатель на этот узел из контейнера front_ptrs предка
					break;
				}
			}
			current->num--; //Уменьшаем счетчик дочерних узлов на 1, т.к. один мы удалили
		}
		else{ //иначе, если символ, не подходящий под условия, является последним в строке, убираем его статус последнего символа в строке и завершаем функцию
			if (i == s.size() - 1)
				current->terminal = false;
			break;
		}
	}
	cout << "Строка была удалена!" << endl << endl;
	return 0;
}
```

### Вспомогательная рекурсивная функция для функции просмотра бора view_bor
```
void recursive(Node* current, string word){
	for (int i = 0; i < current->front_ptrs.size(); i++){ //обходим всех потомков текущего узла
		if (current->front_ptrs[i] != nullptr){ //если i-тый потомок не равен nullptr
			current = current->front_ptrs[i]; //переходим на него и если это не корень, записываем его символ в слово word, а если он терминальный, выводим  word
			if (current->is_root == false){
				word.push_back(current->c);
				if (current->terminal == true){
					cout << word << endl;
				}
			}
			recursive(current, word);
		}
	}
}
```

### Просмотр бора
```
void view_bor(Node* root){
	Node* current = root->back_ptr; //переходим на узел перед корнем
	string word;
	recursive(current, word); //передаём этот узел в рекурсивную функцию
	cout << endl;
}
```

### Поиск строки в боре
```
int search_string(string s, Node* root){ 
	Node* current = root;
	Node* ptr;
	bool find = false;
	for (int i = 0; i < s.size(); i++){
		for (int j = 0; j < current->front_ptrs.size(); j++){ //обходим дочерние узлы (указатели) текущего узла
			ptr = current->front_ptrs[j];
			if (ptr == nullptr){
				cout << "Строка не найдена" << endl << endl;
				return 1;
			}
			if (s[i] == ptr->c){
				current = current->front_ptrs[j];
				find = true;
				break;
			}
		}
		if (find == false){
			cout << "Строка не найдена" << endl << endl;
			return 1;
		}
	}
	if (current->terminal == true){ //когда мы прошли по всему слову и дошли до последнего символа, если он терминальный то строка найдена
		cout << "Строка найдена" << endl << endl;
		return 0;
	}
	else{
		cout << "Строка не найдена" << endl << endl;
		return 1;
	}
}
```

### Удаление бора (рекурсивная функция)
```
void delete_bor(Node* root){
	if (root != nullptr)
		for (int i = 0; i < root->front_ptrs.size(); i++){
			if (root->front_ptrs[i]){ //если потомок существует, рекурсивно снова запускаем для функцию
				delete_bor(root->front_ptrs[i]);
			}
		}
	delete root; //освобождаем память для корневого узла после удаления всех остальных
}
```

Наконец, рассмотрим тесты
-

### TEST 1
Проверим работу функций добавления строки в бор, поиска строки в нем, удаление бора
```
void test1() {
	Node* root = new Node();
	root->back_ptr = new Node(root);

	add_string("hello", root);
	add_string("hoho", root);
	add_string("hi", root);

	cout << "Проверка наличия строк:" << endl;
	cout << "hello: " << (search_string("hello", root) == 0 ? "найдена" : "не найдена") << endl;
	cout << "hoho: " << (search_string("hoho", root) == 0 ? "найдена" : "не найдена") << endl;
	cout << "hi: " << (search_string("hi", root) == 0 ? "найдена" : "не найдена") << endl;
	cout << "test: " << (search_string("test", root) == 0 ? "найдена" : "не найдена") << endl; // Не добавляли

	delete_bor(root);
	cout << "Бор удален" << endl << endl;

}
```
Для начала добавим в бор 3 строки: "hello", "world", "hi", а строку "test" добавлять не будем. Протестируем функцию добавления строки в бор и поиска заданной строки:

![image](https://github.com/user-attachments/assets/48b6a769-c2a0-4584-95fd-c9fd429a26d3)

Тест 1 пройден. Удаляем бор. Так как функция view_bor сработала, выведется сообщение об успешном удалении нашего бора.

### TEST 2
Проверим работу функции удаления строки из бора. Для этого создадим новый бор со строками "pioivis", "president", "pinsk". Удалbм строку president и проверим получилось ли.
```
void test2() {
	Node* root = new Node();
	root->back_ptr = new Node(root);

	add_string("pioivis", root);
	add_string("president", root);
	add_string("pinsk", root);

	cout << "Проверка наличия строк:" << endl;
	cout << "pioivis: " << (search_string("pioivis", root) == 0 ? "найдена" : "не найдена") << endl;
	cout << "president: " << (search_string("president", root) == 0 ? "найдена" : "не найдена") << endl;
	cout << "pinsk: " << (search_string("pinsk", root) == 0 ? "найдена" : "не найдена") << endl << endl;

	delete_string("president", root);

	cout << "Проверка наличия строк:" << endl;
	cout << "pioivis: " << (search_string("pioivis", root) == 0 ? "найдена" : "не найдена") << endl;
	cout << "president: " << (search_string("president", root) == 0 ? "найдена" : "не найдена") << endl;
	cout << "pinsk: " << (search_string("pinsk", root) == 0 ? "найдена" : "не найдена") << endl << endl;

	delete_bor(root);
	cout << "Бор удален" << endl << endl;
	
}
```

Получим

![image](https://github.com/user-attachments/assets/f7e04d92-c7ae-4a70-a5d9-ccb4573d6e49)

Тест 2 пройден. Удаляем бор. Так как функция view_bor сработала, выведется сообщение об успешном удалении нашего бора.

### TEST 3
Проверка работы функции просмотра бора.
```
void test3() {
	Node* root = new Node();
	root->back_ptr = new Node(root);

	add_string("cambridge", root);
	add_string("carrot", root);

	cout << "Содержимое бора:" << endl;
	view_bor(root); 

	delete_bor(root);
	cout << "Бор удален" << endl << endl;
	
}
```

![image](https://github.com/user-attachments/assets/c3252a23-4dde-400e-9bd0-52a1236b1400)

Тест 3 пройден.

### TEST 4
Создадим бор строк "bus","soap","burn". Выведем бор. Удалим строку "bus". Проверим, есть ли в боре эта строка. Выведем бор. Удалим бор.

```
void test4() {
	Node* root = new Node();
	root->back_ptr = new Node(root);

	add_string("bus", root);
	add_string("soap", root);
	add_string("burn", root);

	cout << "Содержимое бора:" << endl;
	view_bor(root);

	delete_string("bus", root);

	cout << "Строка bus: " << (search_string("pioivis", root) == 0 ? "найдена" : "не найдена") << endl;

	cout << "Содержимое бора:" << endl;
	view_bor(root);


	delete_bor(root);
	cout << "Бор удален" << endl << endl;
}
```

Получим 

![image](https://github.com/user-attachments/assets/696c9052-a3bc-4e0b-9eb9-eb14e6693b67)

Тест 4 пройден.

# :point_right: Выводы
Мы организовали работу бора как структуры данных со всеми необходимыми функциямиб реализовали поставленную задачу с использованием ООП и классов на языке программирования С++. Разработали систему тестов, их успешным прохождением подтвердили правильную работу программы.
Особенно полезен Бор в задачах автозаполнения, подсчета слов, поиска по префиксам и других задачах, связанных со строками.
Результаты работы подтверждают необходимость использования Бора для программ, работающих с текстовой информацией, где важны скорость вставки, поиска и удаления данных.

# :computer: Список использованных источников
1. Сайт "Университет ИТМО" \[Электронный ресурс\]. – Режим доступа: [https://neerc.ifmo.ru/wiki/Бор](https://neerc.ifmo.ru/wiki/index.php?title=%D0%91%D0%BE%D1%80).

2. Сайт "Алгоритмика" \[Электронный ресурс\]. – Режим доступа: [https://algorithmica.org/Бор](https://algorithmica.org/ru/trie).

3. Сайт "Информатика для школы" \[Электронный ресурс\]. – Режим доступа: [https://silvertests.ru/Префиксное дерево](https://silvertests.ru/GuideView.aspx?id=32133).

4. Сайт "Киберфорум.ру" \[Электронный ресурс\]. – Режим доступа: [https://www.cyberforum.ru/Очистка префиксного дерева](https://www.cyberforum.ru/cpp-beginners/thread3068833.html)

5. Сайт "Олимпиадное программирование в Бресте и Беларуси" \[Электронный ресурс\]. — Режим доступа: [https://brestprog.by/Бор](https://brestprog.by/topics/trie/)
