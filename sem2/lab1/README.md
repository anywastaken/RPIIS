# Лабораторная работа №1
# :dart: Цель
Исследовать свойства структур данных и разработать библиотеку алгоритмов обработки конкретной структуры данных.
# :pushpin: Постановка задачи
1. Разработать библиотеку для работы со структурой данных Бор на языке С++.
2. Разработать тестовую программу, которая демонстрирует
работоспособность реализованной библиотеки работы со структурой
данных.
3. Разработать систему тестов, которые продемонстрировали бы работоспособность реализованной библиотеки. Система тестов должна
отвечать требованиям полноты, адекватности и непротиворечивости. Система тестов должна учитывать не только корректную работу на
правильных данных, но и предусматривать корректное завершение программы в случае некорректных данных.
4. По результатам выполнения задания составить отчет.
# :page_with_curl: Задача(Вариант 10)
Организовать структуру данных бор (префиксного дерева), организовать функции вставки строки в бор, удаления строки из бора, поиска строки в
боре.
# :book: Список используемых понятий
*Бор* — структура данных для хранения набора строк, представляющая из себя подвешенное дерево с символами на рёбрах. Строки получаются последовательной записью всех символов, хранящихся на рёбрах между корнем бора и терминальной вершиной.
Например, бор для набора образцов {he,she,his,hers} выглядит так:

![Бор](https://github.com/user-attachments/assets/7f523205-380d-4fba-a12f-32de1f6fd7ac)
 
Он устроен в виде дерева, где на ребрах между вершинами написана символы, а некоторые вершины помечены терминальными. 
*Терминальные вершины* - вершины обозначающие конец строки.
Бор хранит ровно те строки, которые получаются, если выписать подряд все буквы на путях от корня до терминальных вершин.

Бор также называют *префиксным деревом*. Каждая вершина бора соответствует префиксу, некоторой добавленной строки. Сам это префикс получается путем последовательной записи символов на ребрах на пути от корня до этой вершины. 
При этом, каждому существующему префиксу соответствует ровно одна вершина. *Корень бора* соответствует пустой строке.

# :mag: Описание программы
Решение поставленной задачи реализации библиотеки для работы со структурой данных бор было реализовано с использованием ООП и классов. Проект представляет собой 3 исходных файла: Node.cpp, mainn.cpp, bor.cpp - и 2 заголовочных файла: node.h, bor.h. 

*Файлы заголовков* — это файлы, которые содержат объявления функций, классов, переменных и других элементов, которые могут быть использованы в нескольких исходных файлах. Они обычно имеют расширение .h . Заголовочные файлы помогают структурировать код, разделяя объявления и определения. Это делает код более читаемым и управляемым. Заголовочные файлы позволяют повторно использовать код в разных частях программы или в разных проектах.


Для начала рассмотрим первый заголовочный файл **node.h**, код выглядит таким образом:
-
```
#pragma once
#include <iostream>
#include <vector>
using namespace std;

class Node //класс для хранения символов и указателей на другие узлы
{
public:
	vector<Node*> front_ptrs = { nullptr };
	Node* back_ptr;
	char c;
	int num = 0;
	bool is_root = false;
	bool terminal = false;

	Node();
	Node(char c);
	Node(Node* p);
}
```
Создаем класс Node для хранения символов и указателей на другие узлы. Здесь объявляем front_ptrs вектор указателей на объекты типа Node , инициализируя с одним элементом nullptr. Он будет хранить указатели на предыдущие узлы, связанные с текущим. Также объявляем указатель на объект back_ptr, который будет хранить ссылки на задние узлы. Булевые переменные is_root - будем использоватьь для проверки является ли данный узел вершиной бора, terminal - является ли терминальной(см. список понятий). Далее объявляем конструкторы, которые будут вызываться при создании объекта класса без параметров, или принимающий символ или указатель(для создания узла, который ссылается на другой узел).

Далее рассмотрим файл Node.cpp (описание класса узла). Он содержит реализации методов класса Node, определенного в заголовочном файле node.h.
-
```
#include "Node.h"
#include <iostream>
#include <vector>

Node::Node(){
	is_root = true;
}
Node::Node(char c){
	this->c = c;
}
Node::Node(Node* p){
	this->front_ptrs[0] = p;
}
```

Сначала реализуем конструкторы для класса Node. 
1. Когда создается объект Node без параметров, первый меняет переменную is_root в true (значит, этот узел является корнем бора).
2. При создании объекта Node с одним параметром типа char, этот конструктор устанавливает значение переменной c в переданное значение.
3. Этот конструктор устанавливает первый элемент вектора front_ptrs в переданный указатель p. Это делается для создания узла, который ссылается на другой узел для их связи в боре.

Следующий заголовочный файл - bor.h.
-
```
#pragma once
#include "Node.h"
#include <string>
using namespace std;

void add_string(string, Node*);

int delete_string(string s, Node* root);

void recursive(Node* current, string word);

void view_bor(Node* root);

int search_string(string s, Node* root);

void delete_bor(Node*);
```
Файл содержит объявления функций, которые работают с бором, они позволяют добавлять, удалять, искать строки и выводить содержимое бора.

Далее рассмотрим bor.cpp, который содержит в себе эти функции
-
Каждую рассмотрим отдельно. Алгоритм описан в комментариях.
### Добавление строки в бор
```
void add_string(string s, Node* root){ 
	Node* current = root; //указатель на текущий узел, начинаем с корня бора
	Node* ptr; //указатель для перебора дочерних узлов
	bool find; //переменная, показывающая, найден ли узел с соответствующим символом
	for (int i = 0; i < s.size(); i++){ //обходим строку
		find = false;
		for (int j = 0; j < current->front_ptrs.size(); j++){ //обходим указатели текущего узла
			ptr = current->front_ptrs[j];
			if (ptr != nullptr){
				if (s[i] == ptr->c){
					current = current->front_ptrs[j];
					find = true;
					break;
				}
			}
		}
		if (find == false){
			if (current->front_ptrs[0] == nullptr)
				current->front_ptrs[current->num] = new Node(s[i]);
			else
				current->front_ptrs.push_back(new Node(s[i]));
			current->num++;
			ptr = current->front_ptrs[current->num - 1];
			ptr->back_ptr = current;
			current = current->front_ptrs[current->num - 1];
		}
		if (i == s.size() - 1)
			current->terminal = true;
	}
	cout << "Строка была добавлена!" << endl << endl;
}
```



# :point_right: Выводы
Мы организовали работу бора как структуры данных со всеми необходимыми функциямиб реализовали поставленную задачу с использованием ООП и классов на языке программирования С++.
Особенно полезен Бор в задачах автозаполнения, подсчета слов, поиска по префиксам и других задачах, связанных со строками.
Результаты работы подтверждают необходимость использования Бора для программ, работающих с текстовой информацией, где важны скорость вставки, поиска и удаления данных.

# :computer: Список использованных источников
1.Сайт "Университет ИТМО" \[Электронный ресурс\]. – Режим доступа:[https://neerc.ifmo.ru/wiki/Бор](https://neerc.ifmo.ru/wiki/index.php?title=%D0%91%D0%BE%D1%80).

2.Сайт "Алгоритмика" \[Электронный ресурс\]. – Режим доступа:[https://algorithmica.org/Бор](https://algorithmica.org/ru/trie).

3.Сайт "Информатика для школы" \[Электронный ресурс\]. – Режим доступа:[https://silvertests.ru/Префиксное дерево](https://silvertests.ru/GuideView.aspx?id=32133).
