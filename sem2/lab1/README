
# README.md

## Цель

Основная цель задания – научиться разрабатывать собственную библиотеку для работы со структурами данных, а именно – реализовать двунаправленный список с набором основных алгоритмов:
- **Создание списка**
- **Вставка элементов** (как в начало, так и в конец)
- **Удаление элементов**
- **Сортировка**
- **Поиск элемента**
- **Объединение списков**
- **Пересечение списков**

## Задача

1. **Разработка библиотеки:**  
   Создать библиотеку на языке C#, реализующую структуру данных – двунаправленный список с полным набором операций.

2. **Тестовая программа:**  
   Разработать демонстрационную программу, подтверждающую корректную работу реализованной библиотеки.

3. **Система тестов:**  
   Спроектировать систему тестирования, которая проверяет:
   - Корректную работу алгоритмов на валидных данных.
   - Безопасное завершение программы при получении некорректных данных.

4. **Отчет:**  
   Составить подробный отчет по выполненному заданию.

## Постановка задачи

Разработка библиотеки направлена на освоение навыков построения собственных решений для работы со структурами данных. В рамках задачи необходимо:
- Реализовать класс двунаправленного списка с поддержкой базовых операций.
- Гарантировать корректное выполнение алгоритмов даже в случаях возникновения ошибок или при неверных входных данных.
- Обеспечить возможность дальнейшего расширения функционала библиотеки.

## Используемые понятия и источники

- **Основные понятия:**  
  двунаправленный список, узел списка, алгоритмы поиска, сортировки, объединения и пересечения списков.
  
- **Алгоритмы:**  
  Реализация алгоритмов основывается на материалах с [metanit](https://metanit.com/).

## Описание реализации

Библиотека реализована в пространстве имен `MyLib` и включает два основных класса:

### MyList<T>

Класс, реализующий двунаправленный список, включает следующие методы:

- **Методы добавления:**
  - `Add(T data)` – добавление элемента в конец списка.
  - `AddFirst(T data)` – добавление элемента в начало списка.

- **Методы удаления и поиска:**
  - `RemoveElement(T data)` – удаление первого найденного элемента, равного заданному.
  - `search(T data)` – поиск элемента в списке.

- **Метод сортировки:**
  - `SortMintoMax()` – сортировка элементов списка методом пузырьковой сортировки.

- **Методы работы со списками:**
  - `mergeList(MyList<T> list1, MyList<T> list2)` – объединение двух списков.
  - `FindIntersection(MyList<T> list1, MyList<T> list2)` – поиск пересечения двух списков.

- **Дополнительные методы:**
  - `print()` – вывод элементов списка в консоль.
  - `Clear()` – очистка списка.

### DoublyNode<T>

Вспомогательный класс для представления узлов двунаправленного списка, содержащий ссылки на предыдущий и следующий элементы.

## Результаты тестирования

*Результаты тестирования будут дополнены. Тестовая программа продемонстрировала корректное выполнение всех операций библиотеки при корректных данных, а также безопасное завершение работы при возникновении ошибок ввода.*

## Вывод

В результате выполнения задания была успешно разработана библиотека для работы с двунаправленным списком, включающая полный набор алгоритмов для работы с данной структурой данных. Реализованные методы демонстрируют корректное выполнение операций по добавлению, удалению, сортировке, поиску, объединению и пересечению списков. Разработанная система тестирования подтверждает надежность и устойчивость библиотеки при различных сценариях использования.

## Код библиотеки

```csharp
using System.Collections;
using System.Collections.Generic;

namespace MyLib
{
    public class MyList<T>
    {
        private DoublyNode<T> head; // головной/первый элемент
        private DoublyNode<T> tail; // последний/хвостовой элемент
        private int count;  // количество элементов в списке

        // добавление элемента
        public void Add(T data)
        {
            DoublyNode<T> node = new DoublyNode<T>(data);
            if (head == null)
                head = node;
            else
            {
                tail.Next = node;
                node.Previous = tail;
            }
            tail = node;
            count++;
        }

        public void AddFirst(T data)
        {
            DoublyNode<T> node = new DoublyNode<T>(data);
            DoublyNode<T> temp = head;
            node.Next = temp;
            head = node;
            if (count == 0)
                tail = head;
            else
                temp.Previous = node;
            count++;
        }

        public void print()
        {
            DoublyNode<T> print = head;
            while (print != null)
            {
                Console.Write(" " + print.Data);
                print = print.Next;
            }
            Console.WriteLine();
        }

        public bool RemoveElement(T data)
        {
            DoublyNode<T> current = head;
            while (current != null) // проходим по всему списку
            {
                if (current.Data.Equals(data)) // сравниваем
                {
                    break;
                }
                current = current.Next;
            }
            if (current != null) // если элемент найден
            {
                if (current.Next != null)
                {
                    current.Next.Previous = current.Previous;
                }
                else
                {
                    tail = current.Previous;
                }
                if (current.Previous != null)
                {
                    current.Previous.Next = current.Next;
                }
                else
                {
                    head = current.Next;
                }
                count--;
                return true;
            }
            return false;
        }

        public int Count { get { return count; } }
        public bool IsPUSTO { get { return count == 0; } }

        public void Clear()
        {
            head = null;
            tail = null;
            count = 0;
        }

        public bool search(T data)
        {
            DoublyNode<T> current = head;
            while (current != null)
            {
                if (current.Data.Equals(data))
                    return true;
                current = current.Next;
            }
            return false;
        }

        public void SortMintoMax()
        {
            if (head == null || head.Next == null)
            {
                return;
            }

            bool swapped;
            do
            {
                swapped = false;
                DoublyNode<T> current = head;

                while (current.Next != null)
                {
                    if (Comparer<T>.Default.Compare(current.Data, current.Next.Data) > 0)
                    {
                        T temp = current.Data;
                        current.Data = current.Next.Data;
                        current.Next.Data = temp;
                        swapped = true;
                    }
                    current = current.Next;
                }
            } while (swapped);
        }

        public void mergeList(MyList<T> list1, MyList<T> list2)
        {
            if (list1.IsPUSTO && list2.IsPUSTO)
            {
                return;
            }
            if (list1.IsPUSTO)
            {
                list1.head = list2.head;
                list1.tail = list2.tail;
                list1.count = list2.count;
                return;
            }
            if (list2.IsPUSTO)
            {
                return;
            }

            list1.tail.Next = list2.head;
            list2.head.Previous = list1.tail;
            list1.tail = list2.tail;
            list1.count += list2.count;

            list2.head = null;
            list2.tail = null;
            list2.count = 0;
        }

        public MyList<T> FindIntersection(MyList<T> list1, MyList<T> list2)
        {
            MyList<T> intersection = new MyList<T>();
            DoublyNode<T> current1 = list1.head;

            while (current1 != null)
            {
                DoublyNode<T> current2 = list2.head;
                while (current2 != null)
                {
                    if (current1.Data.Equals(current2.Data))
                    {
                        intersection.Add(current1.Data);
                        break;
                    }
                    current2 = current2.Next;
                }
                current1 = current1.Next;
            }

            return intersection;
        }
    }
}

namespace MyLib
{
    public class DoublyNode<T>
    {
        public T Data { get; set; }
        public DoublyNode<T> Previous { get; set; } // хранит ссылку
        public DoublyNode<T> Next { get; set; }
        public DoublyNode(T data)
        {
            this.Data = data;
        }

        public DoublyNode() { }
    }
}
