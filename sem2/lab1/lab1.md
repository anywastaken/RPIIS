### Цель
---
Целью моей лабораторной работы была разработка библиотеки для работы с ориентированным графом (Функции вставки вершины, удаления вершины,
вставки дуги, удаления дуги, построения дерева обхода в ширину).

### Задача
---
1. Разработать библиотеку для работы со структурой данных, указанной в
индивидуальном задании, на любом императивнойм языке
программирования (Pascal, C\C++, Java, C#, Python и др.)
2. Разработать тестовую программу, которая демонстрирует
работоспособность реализованной библиотеки работы со структурой
данных.
3. Разработать систему тестов, которые продемонстрировали бы
работоспособность реализованной библиотеки. Система тестов должна
отвечать требованиям полноты, адекватности и непротиворечивости.
Система тестов должна учитывать не только корректную работу на
правильных данных, но и предусматривать корректное завершение
программы в случае некорректных данных.
4. По результатам выполнения задания составить отчет.

### Список используемых понятий
---
- [Граф](https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)) -- математическая абстракция реальной системы любой природы, объекты которой обладают парными связями. Граф как математический объект есть совокупность двух множеств — множества самих объектов, называемого множеством вершин, и множества их парных связей, называемого множеством рёбер. Элемент множества рёбер есть пара элементов множества вершин.
- [Ориентированный граф](https://en.wikipedia.org/wiki/Directed_graph) -- граф, ребра в котором имеют <em>неориентированную природу</em>, что значит, что ребро <a,b> есть так же ребро <b,a>.
- [ Функция обхода в ширину - BFS ](https://neerc.ifmo.ru/wiki/index.php?title=%D0%9E%D0%B1%D1%85%D0%BE%D0%B4_%D0%B2_%D1%88%D0%B8%D1%80%D0%B8%D0%BD%D1%83#:~:text=%D0%9E%D0%B1%D1%85%D0%BE%D0%B4%20%D0%B2%20%D1%88%D0%B8%D1%80%D0%B8%D0%BD%D1%83%20(%D0%9F%D0%BE%D0%B8%D1%81%D0%BA%20%D0%B2,%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%BE%D0%B2%20%D0%B4%D0%BB%D1%8F%20%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%8B%20%D1%81%20%D0%B3%D1%80%D0%B0%D1%84%D0%B0%D0%BC%D0%B8.) -- одна из форм представления графа, в которой указываются связи между инцидентными элементами графа (ребро(дуга) и вершина). Столбцы матрицы соответствуют ребрам, строки — вершинам. Ненулевое значение в ячейке матрицы указывает связь между вершиной и ребром (их инцидентность).
- [Вершина графа(узел)](https://en.wikipedia.org/wiki/Vertex_(graph_theory)) -- фундаментальная единица, из которой формируются графы.
- [Матрица инцидентности](https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%82%D1%80%D0%B8%D1%86%D0%B0_%D0%B8%D0%BD%D1%86%D0%B8%D0%B4%D0%B5%D0%BD%D1%82%D0%BD%D0%BE%D1%81%D1%82%D0%B8) -- одна из форм представления графа, в которой указываются связи между инцидентными элементами графа (ребро(дуга) и вершина). Столбцы матрицы соответствуют ребрам, строки — вершинам. Ненулевое значение в ячейке матрицы указывает связь между вершиной и ребром (их инцидентность).
- [Ребро](https://ru.hexlet.io/courses/graphs/lessons/notation/theory_unit#:~:text=%D0%A0%D0%B5%D0%B1%D1%80%D0%B0%20%D0%B3%D1%80%D0%B0%D1%84%D0%B0.,%D1%81%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B8%D1%82%20%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA%20%D0%BA%D0%BE%D0%BE%D1%80%D0%B4%D0%B8%D0%BD%D0%B0%D1%82%D0%BD%D0%BE%2D%D0%BF%D0%BE%D0%B4%D0%BE%D0%B1%D0%BD%D1%8B%D1%85%20%D0%B2%D0%B5%D1%80%D1%88%D0%B8%D0%BD.) -- одно из множеств графа, служащее в качестве связи между вершинами.

  ### Описание алгоритмов
  ---
1. Первая функция позволяет нам ввести граф, используя матрицу инцидентности. Функция запрашивает количество рёбер и вершин графа. Далее изменяем размер двумерного вектора под размер введённых данных. После этого просим пользователя заполнить матрицу.
```cpp
  void Graph::InputMatrix() {
     cout << "Введите количество вершин и дуг: ";
     cin >> n >> m;

     matrix.resize(n, vector<int>(m, 0));

     cout << "Введите элементы матрицы инцидентности (" << n << " строк и " << m << " столбцов):\n";
     for (int i = 0; i < n; i++) {
         for (int j = 0; j < m; j++) {
             cin >> matrix[i][j];
         }
     }
 }
```
2. Функция вывода матрицы в консоль. 
```cpp
void Graph::PrintMatrix() {
    cout << "\nМатрица инцидентности:" << endl;
    for (const auto& row : matrix) {
        for (int val : row) {
            cout << val << " ";
        }
        cout << endl;
    }
    cout << endl;
}
 ```
3. Функция добавления вершины в граф. В матрицу добавляется пустая строка.
```cpp
    void AddVertex()
    {
        vector<int> newVertex(m, 0);
        matrix.push_back(newVertex);
        n++;
        cout << "Вершина добавлена." << endl << endl;
    }
```
4. Функция удаления вершины. Удаляет строку нужной вершины и все столбцы дуг, которые связаны с удаляемой вершиной
```cpp
 void DelVertex()
    {

        int numVertex;
        cout << endl << "Выберите вершину, которую хотите удалить: " << endl;
        cin >> numVertex;

        if (cin.fail())
        {
            cin.clear();
            cin.ignore(1000, '\n');
            cout << "Некорректный ввод." << endl;
        }

        numVertex--;
        if (numVertex >= 0 && numVertex < n)
        {
            for (int i = matrix[0].size() - 1; i >= 0 ; i--)
            {
                if (matrix[numVertex][i] != 0)
                {
                    for (int k = 0; k < n; k++)
                    {
                        matrix[k].erase(matrix[k].begin() + i);
                    }
                    m--;
                }
            }
            matrix.erase(matrix.begin() + numVertex);
            cout << "Вершина " << ++numVertex << " удалена." << endl;
            n--;
        }
        else
        {
            cout << "Недопустимый индекс для удаления элемента." << endl;
            return;
        }
    }
```
5. Функция добавления дуги. Добавляет столбец дуги.
```cpp
void AddArc()
    {
        int fromVertex, toVertex;
        cout << endl << "Введите 2 вершины, от которой и до которой будет проведена дуга: " << endl;
        cin >> fromVertex >> toVertex;

        if (cin.fail())
        {
            cin.clear();
            cin.ignore(1000, '\n');
            cout << "Некорректный ввод." << endl;
        }

        fromVertex--;
        toVertex--;
        if (fromVertex == toVertex)
        {
            cout << "Невозможно создать петлю. Введите 2 корректных индекса." << endl;
            return;
        }
        if ((fromVertex >= 0 && fromVertex < matrix.size()) && (toVertex >= 0 && toVertex < matrix.size()))
        {
            for (int i = 0; i < n; i++)
            {
                if (i == fromVertex)
                {
                    matrix[i].push_back(1);
                }
                else if (i == toVertex)
                {
                    matrix[i].push_back(-1);
                }
                else
                {
                    matrix[i].push_back(0);
                }
            }
            m++;
        }
        else
        {
            cout << "Недопустимый индекс." << endl;
            return;
        }
        cout << "Дуга от вершины " << fromVertex + 1 << " до вершины " << toVertex + 1 << " добавлена." << endl;
    }
```
6. Функция удаления дуги. Удаляет столбец в матрице.
```cpp
 void DelArc()
    {
        int numArc;
        cout << endl << "Введите номер дуги, которую хотите удалить: " << endl;
        cin >> numArc;

        if (cin.fail())
        {
            cin.clear();
            cin.ignore(1000, '\n');
            cout << "Некорректный ввод." << endl;
            return;
        }

        if (numArc >= 0 && numArc <= matrix[0].size())
        {
            for (int i = 0; i < n; i++)
            {
                matrix[i].erase(matrix[i].begin() + numArc - 1);
            }
            m--;
            cout << "Дуга удалена." << endl;
        }
        else
        {
            cout << "Недопустимый индекс." << endl;
            return;
        }
    }
```
8. Функция обхода в ширину графа. Обходит граф в ширину и выводит дерево обхода с указанием из какой вершины в какую мы попали. 
```cpp
void BFS() 
    {
        int firstVertex;
        cout << "Введите номер вершины, с которой начать обход в ширину." << endl;
        cin >> firstVertex;

        if (cin.fail())
        {
            cin.clear();
            cin.ignore(1000, '\n');
            cout << "Некорректный ввод." << endl;
            return;
        }

        firstVertex--;
        if ((firstVertex < 0) || (firstVertex >= n))
        {
            cout << "Некорректный индекс." << endl;
            return;
        }
        queue<int> q;
        q.push(firstVertex);
        vector<int> d(n, -1); //посещенность вершины
        vector<int> arcs(m, -1); // посещенность дуги
        vector<int> count(n, 0); // счетчик для количества посещений каждой вершины
        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < m; j++)
            {
                if (matrix[i][j] == -1)
                {
                    count[i]++;
                }
            }
        }
        //-----------вывод
        cout << "Количество дуг направленных в каждую вершину:" << endl;
        for (int i = 0; i < n; i++)
        {
            cout << count[i] << "  ";
        }
        cout << endl;
        //-----------
        cout << "Дерево обхода в ширину:" << endl;
        d[firstVertex] = -1;
        while(!q.empty())
        {

            int v = q.front();
            q.pop();
            for (int u = 0; u < m; u++) //u является индексом дуги в данной вершине
            {
                if (matrix[v][u] == 1) //поиск начала дуги
                { 
                    for (int k = 0; k < n; k++) //k является строкой в которой ищется конец дуги
                    {
                        if (matrix[k][u] == -1) //поиск вершины у которой в данном индексе u значение -1
                        {
                            if (arcs[u] == -1)
                            {
                                arcs[u]++;
                                if (d[k] == -1)
                                {
                                    q.push(k);
                                    if (count[k] == 0)
                                    {

                                        d[k]++;
                                    }
                                    else
                                    {
                                        count[k]--;
                                        cout << "Из вершины " << v + 1 << " в вершину " << k + 1 << endl;
                                    }

                                }
                            }
                           
                        }
                    }
                }
            }
        }
        cout << "Обход в ширину окончен." << endl;
    }
```

### Тесты 
---

