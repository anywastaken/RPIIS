# Лабораторная работа №1

## Цель работы
Исследовать свойства структур данных и разработать библиотеку алгоритмов обработки структур данных.

## Задача
Разработать библиотеку для работы со структурой данных и систему тестов, которая продемонстрировала бы работоспособность реализованной библиотеки.

#### Вариант индивидуального задания №13
Красно-черное дерево. Вставка. Удаление. Поиск. Поиск минимума,максимума, ближайшего большего и ближайшего меньшего.

## Определения
**Красно-черное дерево** представляет собой бинарное дерево поиска, в котором баланс сохраняется за счет присваивания узлам красного и черного цветов и выполнения определенных правил, связанных с взаимным расположением узлов определенного цвета

**Черная высота** - количество черных узлов на пути от узла `node` (не считая сам узел) к листу.

### Свойства красно-черного дерева
Бинарное дерево поиска является красно-черным, если оно удовлетворяет следующим свойствам:
1. Каждый узел дерева обладает красным или черным цветом.
2. Корень дерева всегда является черным.
3. Каждый лист дерева является черным.
4. Если узел - красный, то оба его дочерних узла - черные.
5. Для каждого узла все пути от него до листьев, являющихся его потомками, содержат одно и то же количество черных узлов.

## Функции библиотеки

1. Конструктор RBTree:
	* Создает объект красно-черного дерева.
  * Инициализирует лист `NONE` и устанавливает у него черный цвет.
	* Инициализирует указатель на корень дерева и лист `NONE`.
	
2. Метод `insert(self, key: int, value: int = None) -> None`:
	* Создает узел с ключем key и значением value.
	* Проводит поиск места для вставки нового узла в дерево, если узел существует, вызывает исключение `Duplicate`.
  * Если дерево пустое, новый узел становится корнем.
  * Производит балансировку дерева с помощью метода `fix_insert(self, node: RedBlackNode) -> None`.

3. Метод `delete(self, key: int) -> None`:
	* Ищет узел с ключем `key`, если узел не существует вызывает исключение `Missing`.
	* В зависимости от количества потомков удаляемого узла выбирается подходящий случай удаления (0, 1 или 2 потомка).
	* Вызывает функцию `fix_delete`.
	
4. Метод `find_min(self, node: RedBlackNode = None) -> RedBlackNode`:
	* Находит узел с минимальным ключем в поддереве с корнем `node`.
	* Движется влево от корня, пока не достигнет самого левого узла дерева.
	
5. Метод `find_max(self, node: RedBlackNode = None) -> RedBlackNode`:
  * Находит узел с максимальным ключем в поддереве с корнем `node`.
	* Движется вправо от корня, пока не достигнет самого правого узла дерева.
	
6. Метод `find_nearest_max(self, key: int) -> RedBlackNode`:
  * Находит узел `node` с ключем `key`.
	* Находит элемент со следующим по значению ключом.
	* Если у узла есть правый ребенок, то ищет самый левый узел правого поддерева, если нету - ищет первый родительский узел у которого `node` находится в левом поддереве.

8. Метод `find_nearest_min(self, key: int) -> RedBlackNode`:
  * Находит узел `node` с ключем `key`.
	* Находит элемент со предыдущим по значению ключом.
	* Если у узла есть левый ребенок, то ищет самый правый узел левого поддерева, если нету - ищет первый родительский узел у которого `node` находится в правом поддереве.


9. Метод `pre_order_traversal(self, node: RedBlackNode = None) -> None`:
	* Выводит узел `node`.
	* Рекурсивно вызывает функцию `pre_order_traversal` для левого и правого поддеревьев `node`. 

10. Метод `post_order_traversal(self, node: RedBlackNode = None) -> None`:
	* Рекурcивно вызывает функцию `post_order_traversal` для левого и правого поддеревьев `node`.
  * Выводит узел `node`.

11. Метод `in_order_traversal(self, node: RedBlackNode = None) -> None`:
	* Рекурсивно вызывает функцию `in_order_traversal` для левого поддерева.
	* Выводит на экран узел `node`.
	* Рекурсивно вызывает функцию `in_order_traversal` для правого поддерева.

12. Метод `search(self, key: int) -> RedBlackNode`:
	* Сравнивает `key` с ключом узла в котором сейчас находится, если ключи равны, возвращает текущий узел.
	* Если `key` больше, спускается в правое поддерево.
	* Если `key` меньше, спускается в левое поддерево.


## Выводы
Во время выполнения лабораторной работы были исследованы свойства структур данных, разработана библиотека функций для обработки структуры данных и программа для тестирования реальзованной библиотеки, продемонстрировавшая работоспособность.

## Источники
1. Алгоритмы: построение и анализ, 2-е издание. : Пер. с англ. – М. :
Издательский дом «Вильямс», 2005. – 1296 с.

2. [https://github.com/iis-32170x/RPIIS/blob/017a7f06ed1c466f96d403985db294e5d178487c/sem2/lab1/rbtree.cpp)))))](https://habr.com/ru/companies/otus/articles/521034/)
