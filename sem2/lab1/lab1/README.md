# Лабораторная работа №1

## Цель работы
Исследовать свойства структур данных и разработать библиотеку алгоритмов обработки структур данных.

## Задача
Разработать библиотеку для работы со структурой данных и систему тестов, которая продемонстрировала бы работоспособность реализованной библиотеки.

#### Вариант индивидуального задания №13
Красно-черное дерево. Вставка. Удаление. Поиск. Поиск минимума,максимума, ближайшего большего и ближайшего меньшего.

## Определения
**Красно-черное дерево** представляет собой бинарное дерево поиска, в котором баланс сохраняется за счет присваивания узлам красного и черного цветов и выполнения определенных правил, связанных с взаимным расположением узлов определенного цвета

**Черная высота** - количество черных узлов на пути от узла `node` (не считая сам узел) к листу.

### Свойства красно-черного дерева
Бинарное дерево поиска является красно-черным, если оно удовлетворяет следующим свойствам:
1. Каждый узел дерева обладает красным или черным цветом.
2. Корень дерева всегда является черным.
3. Каждый лист дерева является черным.
4. Если узел - красный, то оба его дочерних узла - черные.
5. Для каждого узла все пути от него до листьев, являющихся его потомками, содержат одно и то же количество черных узлов.

## Функции библиотеки

1. Конструктор RBTree:
	* Создает объект красно-черного дерева.
  * Инициализирует лист `NONE` и устанавливает у него черный цвет.
	* Инициализирует указатель на корень дерева и лист `NONE`.
	
2. Метод `insert(self, key: int, value: int = None) -> None`:
	* Создает узел с ключем key и значением value.
	* Проводит поиск места для вставки нового узла в дерево, если узел существует, вызывает исключение `Duplicate`.
  * Если дерево пустое, новый узел становится корнем.
  * Производит балансировку дерева с помощью метода `fix_insert(self, node: RedBlackNode) -> None`.

3. Метод `delete(self, key: int) -> None`:
	* Ищет узел с ключем `key`, если узел не существует вызывает исключение `Missing`.
	* В зависимости от количества потомков удаляемого узла выбирается подходящий случай удаления (0, 1 или 2 потомка).
	* Вызывает функцию `fix_delete`.
	
4. Метод `find_min(self, node: RedBlackNode = None) -> RedBlackNode`:
	* Находит узел с минимальным ключем в поддереве с корнем `node`.
	* Движется влево от корня, пока не достигнет самого левого узла дерева.
	
5. Метод `find_max(self, node: RedBlackNode = None) -> RedBlackNode`:
  * Находит узел с максимальным ключем в поддереве с корнем `node`.
	* Движется вправо от корня, пока не достигнет самого правого узла дерева.
	
6. Метод `find_nearest_max(self, key: int) -> RedBlackNode`:
  * Находит узел `node` с ключем `key`.
	* Находит элемент со следующим по значению ключом.
	* Если у узла есть правый ребенок, то ищет самый левый узел правого поддерева, если нету - ищет первый родительский узел у которого `node` находится в левом поддереве.

8. Метод `find_nearest_min(self, key: int) -> RedBlackNode`:
  * Находит узел `node` с ключем `key`.
	* Находит элемент со предыдущим по значению ключом.
	* Если у узла есть левый ребенок, то ищет самый правый узел левого поддерева, если нету - ищет первый родительский узел у которого `node` находится в правом поддереве.


9. Метод `pre_order_traversal(self, node: RedBlackNode = None) -> None`:
	* Выводит узел `node`.
	* Рекурсивно вызывает функцию `pre_order_traversal` для левого и правого поддеревьев `node`. 

10. Метод `post_order_traversal(self, node: RedBlackNode = None) -> None`:
	* Рекурcивно вызывает функцию `post_order_traversal` для левого и правого поддеревьев `node`.
  * Выводит узел `node`.

11. Метод `in_order_traversal(self, node: RedBlackNode = None) -> None`:
	* Рекурсивно вызывает функцию `in_order_traversal` для левого поддерева.
	* Выводит на экран узел `node`.
	* Рекурсивно вызывает функцию `in_order_traversal` для правого поддерева.

12. Метод `search(self, key: int) -> RedBlackNode`:
	* Сравнивает `key` с ключом узла в котором сейчас находится, если ключи равны, возвращает текущий узел.
	* Если `key` больше, спускается в правое поддерево.
	* Если `key` меньше, спускается в левое поддерево.

13. Методы `left_rotate(self, x: RedBlackNode) -> None` и `right_rotate(self, y: RedBlackNode) -> None`:
        * Выполняют левый и правый повороты дерева относитлеьно узла `node`.

14. Метод `fix_delete(self, x: RedBlackNode) -> None`:
        * Восстанавливает свойства кч-дерева.
    	* Рассматривает 4 случая, если `x` - левый ребенок своего родителя:
    		1) брат удаляемого узла красный.
    		2) оба ребенка брата - черные
    		3) левый ребенок брата красный, а правый - черный.
    		4) правый ребенок брата красный.
        * Если `x` - правый ребенок, рассматривает 4 случая симметричных вышеописанным.

## Тестирование библиотеки
Для тестирования будем использовать функцию `check_properties(
        self, node: RedBlackNode, black_count=0, black_counts=None
    ) -> bool`, которая будет рекурсивно проверять выполняются ли свойства кч-дерева:
        * Если текущий узел `NONE`Б добавляем в массив значение черной высоты, полученное при спуске.
	* Если текущий узел - корень, а его цвет - красный, возвращаем ошибку.
	* Если текущий узел красный, проверяем, чтобы его дети были черного цвета, иначе возвращаем ошибку.
 	* Если текущий узел - черный, увеличиваем черную высоту на один.
  	* Рекурсивно высываем функцию для левого и правого поддеревьев.
	* Если в правом и левом поддереве выполняются кч-свойства, проверяем равны ли черные высоты от текущего узла до листьев, если не равны, возвращаем ошибку.


## Выводы
Во время выполнения лабораторной работы были исследованы свойства структур данных, разработана библиотека функций для обработки структуры данных и программа для тестирования реальзованной библиотеки, продемонстрировавшая работоспособность.

## Источники
1. Алгоритмы: построение и анализ, 2-е издание. : Пер. с англ. – М. :
Издательский дом «Вильямс», 2005. – 1296 с.

2. [https://habr.com/ru/companies/otus/articles/521034/](https://habr.com/ru/companies/otus/articles/521034/)
   
3. [https://habr.com/ru/articles/330644/](https://habr.com/ru/articles/330644/)
   
