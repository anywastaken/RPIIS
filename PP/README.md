# Расчетная работа на тему "Решение теоретико-графовой задачи"
**Цель:** Получить навыки формализации и обработки информации с использованием семантических сетей.

**Задача:** Реализовать на языке c++ код для нахождения радиуса взвешенного неориентированного графа.

----

# Список понятий:
`Граф`- объект,состоящий из множеств точек и линий, которые находятся между собой в некотором отношении. Множество точек графа называется `множеством вершин`. Множество линий, соединяющих любые пары вершин, называется `множеством ребер или дуг`.

`Нериентированный граф` - граф, вершины которого соединены ребрами.

`Взвешенный граф`- граф, каждому ребру которого поставлено в соответствие некое значение (вес ребра).

`Список смежности(список инцидентности)` одной вершины графа включает номера вершин, смежных с ней.

Например:

![Снимок экрана 2023-11-22 022302](https://github.com/iis-32170x/RPIIS/assets/145226586/07570789-eb31-4ac6-bdcd-ca5cabd4b555)

`Эксцентриситетом вершины` называется расстояние до самой дальней вершины графа. 

`Радиусом` графа называется минимальный эксцентриситет среди всех вершин графа.

`Расстояние между вершинами` – это длина кратчайшего пути между вершинами.

`Связный граф` - граф, в котором между двумя любыми вершинами существует путь.

`Несвязный граф` - граф, в котором существует хотя бы одна пара вершин, между которыми нет пути.

`Пустой граф` - граф, не содержащий ребер.

----

# Алгоритм Беллмана-Форда

![Снимок экрана 2023-12-12 190122](https://github.com/iis-32170x/RPIIS/assets/145226586/a1f87b01-ba4f-4fc4-a01b-6b9ea8ef2ae7)

Широко используемый алгоритм в теории графов и сетевом анализе. Он используется для поиска кратчайшего пути от одной исходной вершины ко всем остальным вершинам взвешенного графа, даже если граф содержит ребра с отрицательным весом. 

**Ключевые идеи:**

 ⁃ Кратчайший путь из одного источника.
 
Беллман-Форд фокусируется на поиске кратчайшего пути от исходной вершины ко всем остальным вершинам графа.

 ⁃ Ребра с отрицательным весом.
 
В отличие от алгоритма Дейкстры, алгоритм Беллмана-Форда может обрабатывать графы с ребрами с отрицательным весом. Однако он не может обрабатывать графы с отрицательными весовыми циклами.

 ⁃ Релаксация
 
Основная операция Беллмана-Форда – это **релаксация**. Алгоритм применяемая к ребру графа, направленному от одной вершины к другой, с целью улучшения оценки кратчайшего пути между этими двумя вершинами.Основная идея заключается в том, чтобы проверить, можно ли улучшить текущую оценку длины пути до вершины, используя новое ребро.

Сложность: O(V*E)

----

----

# Алгоритм решения поставленной задачи:

1. **Инициализация:**
   - Для каждой вершины графа мы начинаем с предположения, что самое короткое расстояние до нее из начальной вершины - это "бесконечность", за исключением самой начальной вершины, до которой расстояние равно 0.

2. **Обход вершин:**
   - Мы начинаем с очереди, в которую помещаем начальную вершину.
   - Затем, пока у нас есть вершины в очереди, мы берем вершину из очереди и рассматриваем ее соседей.
   - Если мы можем добраться до соседа более коротким путем, чем тот, который мы ранее знали, мы обновляем это расстояние и добавляем соседа в очередь для дальнейшего рассмотрения.

3. **Нахождение радиуса:**
   - После обхода графа мы находим максимальное расстояние от данной вершины до любой другой вершины в графе.
   - Это максимальное расстояние и является эксцентриситетом текущей вершины.
   - Затем, чтобы найти радиус графа, мы выбираем минимальный из всех найденных эксцентриситетов.

4. **Результат:**
   - Радиус графа - это минимальный эксцентриситет среди всех вершин графа.
  
----

```C++
#include <iostream> 
#include <vector> 
#include <queue> 
#include <climits> 
#include <fstream> 
using namespace std;

struct Edge {
    int to;        // информация о конечной вершине *to* и весе *weight* ребра
    int weight;
};

int findEccentricity(vector<vector<Edge>>& adjList, int start, int n) {
    vector<int> dist(n, INT_MAX);
    dist[start] = 0;

    queue<int> q;
    q.push(start);

    while (!q.empty()) {
        int cur = q.front();
        q.pop();

        for (const Edge& edge : adjList[cur]) {
            int neighbor = edge.to;
            int weight = edge.weight;

            if (dist[neighbor] > dist[cur] + weight) {
                dist[neighbor] = dist[cur] + weight;
                q.push(neighbor);
            }
        }
    }

    int maxDist = 0;
    for (int i = 0; i < n; ++i) {
        maxDist = max(maxDist, dist[i]);
    }

    return maxDist;
}

int findGraphRadius(vector<vector<Edge>>& adjList, int n) {
    int minEccentricity = INT_MAX;

    for (int i = 0; i < n; ++i) {
        int eccentricity = findEccentricity(adjList, i, n);
        minEccentricity = min(minEccentricity, eccentricity);
    }

    return (minEccentricity == INT_MAX) ? -1 : minEccentricity;
}

void run_testcase(const char* file) {
    ifstream input(file);
    if (!input.is_open()) {
        cerr << "Nevozmozhno otkryt fayl: " << file << endl;
        return;
    }

    int n, m;
    input >> n >> m;

    vector<vector<Edge>> adjList(n);

    cout << "Spisok smezhnosti: " << endl;
    for (int i = 0; i < m; i++) {
        int u, v, w;
        input >> u >> v >> w;
        u--, v--;

        Edge edge_to_v = { v, w };
        Edge edge_to_u = { u, w };

        adjList[u].push_back(edge_to_v);
        adjList[v].push_back(edge_to_u);
        cout << u + 1 << "<->" << v + 1 << " " << w << endl;
    }

    input.close();

    int graphRadius = findGraphRadius(adjList, n);
    if (graphRadius == -1) {
        cout << "Graf nesvyaznyy ili pustoy " << endl;
    }
    else {
        cout << "Radius grafa dlya fayla " << file << ": " << graphRadius << endl;
    }
    cout << "--------------------------------------------------\n";
}

int main() {
    setlocale(LC_ALL, "ru");

    int choice;
    do {
        cout << "Выберите граф для анализа:\n";
        cout << "1. graph1.txt\n";
        cout << "2. graph2.txt\n";
        cout << "3. graph3.txt\n";
        cout << "4. graph4.txt\n";
        cout << "5. graph5.txt\n";
        cout << "0. Выход\n";
        cout << "Ваш выбор: ";
        cin >> choice;

        switch (choice) {
        case 1:
            run_testcase("graph1.txt");
            break;
        case 2:
            run_testcase("graph2.txt");
            break;
        case 3:
            run_testcase("graph3.txt");
            break;
        case 4:
            run_testcase("graph4.txt");
            break;
        case 5:
            run_testcase("graph5.txt");
            break;
        case 0:
            cout << "Выход из программы." << endl;
            break;
        default:
            cout << "Неверный выбор. Пожалуйста, попробуйте снова." << endl;
        }
    } while (choice != 0);

    return 0;
}
```
#Источник информации:
[Graf](https://ru.wikipedia.org/wiki/%D0%93%D1%80%D0%B0%D1%84_(%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0))
## Вывод
 В результате выполнения данной работы были получены следующие практические навыки:
1.изучены основы теории графов;

2.изучены способы представления графов;

3.изучены базовые алгоритмы для работы с графами.
