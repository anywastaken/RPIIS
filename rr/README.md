<h1 align="center">Расчетная работа</h1>

## Цели:
* Изучить основные понятия в теории графов 
* Научиться различать виды графов
* Уметь использовать основные алгоритмы при работе с графами 

## Задачи:
* Выполнить свой вариант расчетной работы
* Перенести получившееся решение на язык программирования С++
* Ознакомиться с основными алгоритмами по работе с графами

## Вариант:
Вариант расчетной работы - 2.6: определить число вершинной связности невзвешенного неориентированного графа, представляя его в виде списка смежности.
## Список ключевых понятий 
* ***Граф*** — это термин из теории математики, который описывает структуру, состоящую из вершин и ребер, соединяющих их между собой.  
* ***Ориентированный граф*** - граф, рёбрам которого присвоено направление. Направленные рёбра именуются также дугами, а в некоторых источниках и просто рёбрами.
* ***Неориентированный граф*** - граф, в котором рёбра не указывают направление. Это значит, что из любой вершины можно попасть в любую точку графа.
* ***Связный граф*** — граф, в котором существует путь между любой парой вершин. Из каждой вершины по рёбрам можно добраться до любой другой вершины. В связном графе нет изолированных вершин или групп, которые не связаны с остальными частями графа.
* ***Взвешенный граф*** — граф, в котором каждому ребру присвоено числовое значение — вес. Это может быть расстояние, время, стоимость, мощность или другая характеристика, связанная с соединением вершин.
* ***Невзвешенный граф*** — это граф, в котором рёбра и вершины не имеют никаких числовых значений, а только факт наличия или отсутствия связи между вершинами.
* ***Список смежности*** — один из способов представления графа в виде коллекции списков вершин. Каждой вершине графа соответствует список, состоящий из «соседей» этой вершины.
   ## Рассмотрим пример неориентирванного графа
  ![Снимок экрана 2024-12-19 234806](https://github.com/user-attachments/assets/61357bde-7851-4756-9717-db27bd796732)
  

Список смежности для данного графа будет выглядеть следующим образом:
  ```
  5 4
  1 2
  2 1 3
  3 2 4
  4 3 5
  5 4
  ```

В первой строке указывается кол-во вершин и ребер, а в каждой последующей: вершина и смежные ей вершины.

***Вершинной связностью графа*** называется наименьшее число вершин, которое нужно удалить, чтобы граф перестал быть связным. Для этого графа число вершинной связности (ЧВС) есть число 1. Удаляя вершину 2,3 или 4, мы разделяем граф на две несвязные компоненты:

![image](https://github.com/user-attachments/assets/6186c380-26d6-4f12-b03e-c115a108dcb4)

(Удалена вершина номер 3)

## **Алгоритм решения задачи**
* ***1. Проверка начальной связности:***

Подсчитывается количество компонент связности графа без удаления вершин.
Если граф изначально несвязен (число компонент > 1), вершинная связность равна 0, и обработка графа завершается.

* ***2. Перебор всех возможных комбинаций удаляемых вершин:***

Перебираются все подмножества вершин графа.
Каждое подмножество определяется с помощью двоичного представления чисел:
Например, если у графа 3 вершины, то перебираются комбинации удаления: {0}, {1}, {2}, {0, 1}, {0, 2}, {1, 2}, {0, 1, 2}.

* ***3. Удаление выбранных вершин:***

Для каждого подмножества вершин из графа временно удаляются указанные вершины и все их рёбра.
Проверка связности после удаления:

Подсчитывается количество компонент связности графа после удаления выбранных вершин.
Если граф становится несвязным (число компонент > 1), запоминается размер текущего подмножества удалённых вершин.
* ***4.Поиск минимального множества:***

Сравниваются размеры всех подмножеств, которые делают граф несвязным.
Минимальное количество вершин, удаление которых приводит к несвязности, сохраняется как число вершинной связности.

Поиск ЧВС проходит по формуле О(2 
V
 ⋅(V+E)), где 
V — число вершин,
E — число рёбер.
## Обьяснение кода

 ```
void dfs(const vector<vector<int>>& graph, int v, vector<bool>& visited, const set<int>& removedVertices) {
    visited[v] = true;
    for (int neighbor : graph[v]) {
        if (!visited[neighbor] && removedVertices.find(neighbor) == removedVertices.end()) { //мнво удаленных вершин
            dfs(graph, neighbor, visited, removedVertices);
        }
    }
}
 ```

Используется поиск в глубину для обхода всех вершиин графа. Создаем двумерный массив, где graph[i] — список соседей вершины i. 

 ```
int concomp(const vector<vector<int>>& graph, int vertexCount, const set<int>& removedVertices) {
    vector<bool> visited(vertexCount, false);//массив visited длиной vertexCount
    int components = 0;

    for (int i = 0; i < vertexCount; i++) {
        if (!visited[i] && removedVertices.find(i) == removedVertices.end()) {
            dfs(graph, i, visited, removedVertices);
            components++;
        }
    }

    return components;
 ```
Эта функция concomp подсчитывает число компонент связности в графе после удаления указанных вершин. Создаётся булевый массив visited размером vertexCount. Каждая ячейка изначально равна false, что означает, что вершина ещё не была посещена при обходе графа. Если вершина i доступна, вызывается функция DFS (поиск в глубину), которая помечает все вершины текущей связной компоненты как посещённые, учитывает удалённые вершины.

 ```
for (int i = 0; i < vertexCount; i++) {
    getline(file, line);
    stringstream ss(line);

    int vertex, neighbor;
    ss >> vertex;
    vertex--;

    while (ss >> neighbor) {
        neighbor--;
        graph[vertex].push_back(neighbor);
    }
}
 ```

Здесь читается список смежности из файла. Считывается первое число vertex, которое указывает номер вершины. Из потока ss считываются числа (соседи текущей вершины). Соседняя вершина добавлятется в список смежности через neighbor.

 ```
 if (concomp(graph, vertexCount, {}) > 1) {
     cout << "Число вершинной связности для графа " << g << ": 0" << endl;
     continue;
 }
 ```
 Если ЧВС изначально равно 0(то есть граф сразу имеет 2 и более компоненты связности), сразу выводится 0.
 
```
  for (int mask = 1; mask < (1 << vertexCount); mask++) {
     set<int> removedVertices;
     for (int i = 0; i < vertexCount; i++) {
         if (mask & (1 << i)) {//включена ли вершина
             removedVertices.insert(i);
         }
     }

     int components = concomp(graph, vertexCount, removedVertices);

     // Если граф стал несвязным (компонент > 1)
     if (components > 1) {
         сonnectivity = min(сonnectivity, (int)removedVertices.size());
     }
 }
```

Этот фрагмент кода вычисляет ЧВС путём перебора всех возможных подмножеств удаляемых вершин. Например, если vertexCount=3, то маска принимает значения 2^3-1=7 в виде двоичного кода. 

```
001 (удаляем вершину 0),
010 (удаляем вершину 1),
011 (удаляем вершины 0 и 1)
```

Если i-я вершина включена в mask, она добавляется в множество removedVertices. Далее вызывается concomp, которая считает новое кол-во компонент связности. Если граф стал несвязным, вычисляется минимальное количество удаляемых вершин, необходимое для этого. Минимальное количество удаляемых вершин, при котором граф становится несвязным, сохраняется в переменной сonnectivity.

## Тестовые примеры
### №1 

```
4 2
1 2
2 1
3 4
4 3
```

![image](https://github.com/user-attachments/assets/0867be91-16be-468d-8f3c-4d31af364f2e)

 Данный граф изначально несвязный, поэтому вывод для графа будет:
 
 ![image](https://github.com/user-attachments/assets/3f4a72a5-b073-4839-9890-6733998c7963)

### №2

```
4 3
1 2 3
2 1 4
3 1
4 2
```

![image](https://github.com/user-attachments/assets/a17bac16-05c0-4e1f-9615-23d84a394371)

 Удаляя в этом графе вершины 2 или 1, делаем граф несвязным. Вывод программы:

 ![image](https://github.com/user-attachments/assets/e0bf6f89-1e3f-46f8-8160-f51ab78270f2)

### №3
```
3 2 
1 2
2 1 3
3 2
```

![image](https://github.com/user-attachments/assets/3e5c9785-6710-4fbc-ad5c-c62459a83405)

 Элементарный граф-треугольник. Ситуация аналогична с тестовым примером №2.

 ![image](https://github.com/user-attachments/assets/bde48ca5-3877-4e8b-a4f8-170c6d30fc3a)

### №4
```
5 4 
1 2 3
2 1 4
3 1 5
4 2
5 3
```
![image](https://github.com/user-attachments/assets/4cfdadc6-d013-4879-b72e-8313fef05016)

 Для этого графа сразу моежт показаться правильным ответ 2. Однако вершины 5 и 4 соединены только с одной вершиной, удаляя которые, граф теряет связностью Таким образом вывод в консоли:
 
 ![image](https://github.com/user-attachments/assets/ba777954-21d1-4ccf-a782-da445b57b75a)

### №5
```
4 4
1 2 4 
2 1 3
3 2 4
4 1 3
```
![image](https://github.com/user-attachments/assets/ba0e8888-7721-4975-984b-91c94431cc58)

Циклический граф. Каждая вершина соединена с двумя другими. Таким образом ЧВс равно 2. 

![image](https://github.com/user-attachments/assets/9ac20ed9-861e-44c2-aa89-48eb62b70faf)

# Вывод

## В данной работе был мной были ихучены основные понятия о графах,способы их изображения и представления, а также способ поиска числа вершинной связности на языке С++.

## Список использованной литературы

1. Свободная энциклопедия "Википедия" \[Электронный ресурс\]. – Режим доступа:
[https://ru.wikipedia.org/wiki/Диаметр](https://ru.wikipedia.org/wiki/%D0%94%D0%B8%D0%B0%D0%BC%D0%B5%D1%82%D1%80)
2. Свободная энциклопедия "Википедия" \[Электронный ресурс\]. – Режим доступа: [https://ru.wikipedia.org/wiki/Список_смежности](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D1%81%D0%BC%D0%B5%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B8#:~:text=%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA%20%D1%81%D0%BC%D0%B5%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B8%20%E2%80%94%20%D0%BE%D0%B4%D0%B8%D0%BD%20%D0%B8%D0%B7%20%D1%81%D0%BF%D0%BE%D1%81%D0%BE%D0%B1%D0%BE%D0%B2,%2C%20%7Ba%2C%20b%7D.)
3. Сайт Универстит ИТМО \[Электронный ресурс\]. -Режим доступа: [Вершинная,_рёберная_связность,_связь_между_ними_и_минимальной_степенью_вершины](https://neerc.ifmo.ru/wiki/index.php?title=%D0%92%D0%B5%D1%80%D1%88%D0%B8%D0%BD%D0%BD%D0%B0%D1%8F,_%D1%80%D1%91%D0%B1%D0%B5%D1%80%D0%BD%D0%B0%D1%8F_%D1%81%D0%B2%D1%8F%D0%B7%D0%BD%D0%BE%D1%81%D1%82%D1%8C,_%D1%81%D0%B2%D1%8F%D0%B7%D1%8C_%D0%BC%D0%B5%D0%B6%D0%B4%D1%83_%D0%BD%D0%B8%D0%BC%D0%B8_%D0%B8_%D0%BC%D0%B8%D0%BD%D0%B8%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B9_%D1%81%D1%82%D0%B5%D0%BF%D0%B5%D0%BD%D1%8C%D1%8E_%D0%B2%D0%B5%D1%80%D1%88%D0%B8%D0%BD%D1%8B)
4. Сайт "Хабр. Статьи"  \[Электронный ресурс\]. - Режим доступа: [https://habr.com/ru/articles/Алгоритм_Флойда_Уоршелла](https://habr.com/ru/articles/105825/)
5. Оре-О-Теория-графов. 
