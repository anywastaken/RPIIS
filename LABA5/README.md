# Лабораторная работа 5
 
### Цель: 
 
Освоить командные оболочки cmd и shell:
+ изучить основные встроенные команды,
+ научиться писать файлы сценариев,
+ научиться соотносить командные оболочки для разных OS.
+ Освоить командное окружение для OS семейства Unix(утилиты из пакета GNU Core Utilities), и соответствующие им утилиты для OS семейства MS Windows.
### Условия задания
51 Создать файл sh и bat, который выполняет следующее: 
На вход пакетному файлу приходит абсолютный путь к папке (как параметр пакетного файла). Если такой папки нет, то писать “Данной папки нет” и завершить выполнение программы. Если такая папка есть, то в ней и ее подкаталогах найти все файлы txt, взять у каждого из них 5-ю строку файла и записать их файл log.txt в порядке возрастания (по строкам)
## Batch файл
- ### Код программы :computer:
```batch
@echo off
setlocal enabledelayedexpansion
chcp 65001

if "%~1"=="" (
   echo Укажите путь к папке
    exit /b
)

set "folder=%~1"

if not exist "!folder!" (
   echo Данной папки нет
    exit /b
)

> log.txt echo.

for /r "%folder%" %%f in (*.txt) do (
    set "line="
    set /a count=0
    for /f "usebackq tokens=*" %%l in ("%%f") do (
        set /a count+=1
        if !count! equ 5 (
            set "line=%%l"
      echo !line!
    echo !line! >> log.txt
        )
    )
 )

sort log.txt /o log.txt

echo Готово
pause

```
### Пояснение кода
Отключает вывод команд в командной строке, что делает вывод более чистым и удобным для пользователя.
```
@echo off
```
Устанавливает кодировку UTF-8, чтобы корректно отображать кириллические символы.
```
chcp 65001
```
 Эта команда включает отложенную обработку переменных.
```
setlocal enabledelayedexpansion
```
Эта проверка проверяет, был ли передан аргумент при запуске скрипта. "%~1" обращается к первому аргументу командной строки. Если аргумент отсутствует (пустой), команда exit /b завершает выполнение скрипта.
```
if "%~1"=="" (
    echo Укажите путь к папке
    exit /b
)
```
Здесь переменной folder присваивается значение первого аргумента командной строки (путь к папке)
```
set "folder=%~1"

```
Эта проверка определяет, существует ли указанная папка. Если папка не существует, выполнение скрипта завершается.
```
if not exist "!folder!" (
    exit /b
)

```
Эта команда создает или очищает файл log.txt
```
> log.txt echo.
```
Этот цикл проходит по всем .txt файлам в указанной папке и всех её подкаталогах. Переменная %%f будет содержать путь к каждому найденному текстовому файлу.
```
for /r "%folder%" %%f in (*.txt) do (
```
Здесь переменной line присваивается пустое значение, а переменной count — значение 0. 
```
    set "line="
    set /a count=0
```
Этот вложенный цикл читает строки из текущего текстового файла (%%f). Опция usebackq позволяет использовать кавычки для указания имени файла. tokens=* означает, что мы хотим получить всю строку.
```
    for /f "usebackq tokens=*" %%l in ("%%f") do (
```
 Эта команда увеличивает значение переменной count на 1 каждый раз, когда читается новая строка из файла.
```
        set /a count+=1
```
• Здесь проверяется, равен ли счетчик строк (переменная count) 5. Если да, то:

  • Переменной line присваивается значение пятой строки (%%l).

  • Значение переменной line выводится на экран с помощью echo !line!.

  • Значение переменной line добавляется в файл log.txt с помощью echo !line! >> log.txt.
```
        if !count! equ 5 (
            set "line=%%l"
            echo !line!
            echo !line! >> log.txt
        )
)
)
```
Эта команда сортирует содержимое файла log.txt и перезаписывает его отсортированным содержимым.
```
       sort log.txt /o log.txt
```
Выводит сообщение "Готово" в консоль, указывая на завершение выполнения скрипта.
```
echo Готово
```
Эта команда приостанавливает выполнение скрипта и ждет, пока пользователь нажмет любую клавишу.
```
pause
```
###1. Скрипт для Windows:

```
  • Сохраните код в файл bat.bat.

   • Запустите его с указанием пути к папке: bat.bat C:\путь\к\папке.
```
## Shell файл
- ### Код программы :computer:
```bash
#!/bin/bash
if [ "$#" -ne 1 ]; then
    echo "Использование: $0 <абсолютный_путь_к_папке>"
    exit 1
fi

directory="$1"

if [ ! -d "$directory" ]; then
    echo "Данной папки нет"
    exit 1
fi

log_file="log1.txt"
> "$log_file"

find "$directory" -type f -name "*.txt" | while read -r file; do
    fifth_line=$(sed -n '5p' "$file")
    if [ ! -z "$fifth_line" ]; then
        echo "$fifth_line" >> "$log_file"
    fi
done

sort -u "$log_file" -o "$log_file"

```
### Пояснение кода
Указывает, что скрипт должен выполняться с использованием интерпретатора bash.
```
#!/bin/bash
```
Эта строка проверяет, сколько аргументов было передано скрипту. $# содержит количество аргументов. -ne означает "не равно". Если количество аргументов не равно 1, то условие выполняется.
```
if [ "$#" -ne 1 ]; then
```
Если условие выше истинно (т.е. аргументов не 1), то выводится сообщение о неправильном использовании скрипта. $0 содержит имя самого скрипта.
```
echo "Использование: $0 <абсолютный_путь_к_папке>"
```
Завершает выполнение скрипта с кодом возврата 1, что обычно указывает на ошибку.
```
exit 1
```
Закрывает условный блок if.
```
fi
```
Присваивает переменной directory значение первого аргумента командной строки, который был передан скрипту.
```
directory="$1"
```
Проверяет, существует ли директория, указанная в переменной directory. -d проверяет, является ли путь директорией, а ! инвертирует результат проверки.
```
if [ ! -d "$directory" ]; then
```
Если директория не существует, выводится сообщение о том, что папка не найдена.
```
echo "Данной папки нет"
```
Завершает выполнение скрипта с кодом возврата 1.
```
exit 1
```
Закрывает условный блок if.
```
  fi
```
Создает переменную log_file и присваивает ей имя файла для логирования, в данном случае log1.txt.
```
log_file="log1.txt"
```
Очищает содержимое файла log1.txt, если он существует, или создает его, если его нет.
```
> "$log_file"
```
Использует команду find для поиска всех файлов с расширением .txt в указанной директории. Результаты передаются в цикл while, который читает каждый найденный файл по одному.
```
find "$directory" -type f -name "*.txt" | while read -r file; do
```
Использует команду sed, чтобы извлечь пятую строку из текущего файла (переменная $file). Опция -n подавляет вывод, а 5p говорит sed напечатать только пятую строку.
```
fifth_line=$(sed -n '5p' "$file")
```
Проверяет, не является ли переменная fifth_line пустой. -z проверяет, является ли строка пустой; ! инвертирует результат.
```
if [ ! -z "$fifth_line" ]; then
```
Если пятая строка не пустая, она добавляется в файл логов log1.txt. Оператор >> используется для добавления текста в конец файла.
```
echo "$fifth_line" >> "$log_file"
```
Закрывает условный блок и завершает цикл while.
```
    fi
done
```
Сортирует содержимое файла log1.txt, удаляя дубликаты (-u), и записывает отсортированный результат обратно в тот же файл (-o "$log_file").
```
sort -u "$log_file" -o "$log_file"
```
###2.Скрипт для Linux/Unix:

```
  • Сохраните код в файл shell.sh.

   • Дайте ему права на выполнение: chmod +x shell.sh.

   • Запустите его с указанием пути к папке: ./shell.sh /путь/к/папке.
```

### Выводы: 
 В ходе выполнения лабораторной работы по освоению командных оболочек cmd (для операционных систем семейства MS Windows) и shell (для операционных систем семейства Unix) были получены практические навыки работы с консольными программами и командами в различных операционных системах. 
