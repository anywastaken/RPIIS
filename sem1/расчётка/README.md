<h1 align = "center">Расчетная работа</h1>

## Цель работы

1) Изучить основные понятия в теории графов.
2) Научиться различать виды графов.
3) Уметь использовать основные алгоритмы при работе с графами.

## Вариант расчетной работы
В моем варианте расчетной работы нужно было найти число реберной связности графа.

## Теоретические сведения для выполнения расчетной работы

Неориентированный граф - граф, в котором рёбра не указывают направление. Это значит, что из любой вершины можно попасть в любую точку графа. 

Ориентированный граф - граф, рёбрам которого присвоено направление. Направленные рёбра именуются также дугами, а в некоторых источниках и просто рёбрами. 

Связный граф — граф, в котором существует путь между любой парой вершин. Из каждой вершины по рёбрам можно добраться до любой другой вершины. В связном графе нет изолированных вершин или групп, которые не связаны с остальными частями графа.

Число реберной связности графа - это число ребер, которые нужно удалить, чтобы граф стал несвязным.
 
![alt text](images/image1.jpg)
В данном графе нужно убрать одно ребро, чтобы сделать его несвязным. Следовательно число реберной связности - 1.

## Алгоритмы для выполнения расчетной работы

### Алгоритм обхода в глубину
Стратегия поиска в глубину, как и следует из названия, состоит в том, чтобы идти «вглубь» графа, насколько это возможно. Алгоритм поиска описывается рекурсивно: перебираем все исходящие из рассматриваемой вершины рёбра. Если ребро ведёт в вершину, которая не была рассмотрена ранее, то запускаем алгоритм от этой нерассмотренной вершины, а после возвращаемся и продолжаем перебирать рёбра. Возврат происходит в том случае, если в рассматриваемой вершине не осталось рёбер, которые ведут в нерассмотренную вершину. Если после завершения алгоритма не все вершины были рассмотрены, то необходимо запустить алгоритм от одной из нерассмотренных вершин.

<img src="images/dfs.gif">

Код для алгоритма обхода в глубину:

![alt text](images/image_dfs.png)

Мой алгоритм обхода в глубину возвращает вектор из true/false, где true в i-той ячейке означает, что i-тая вершина была посещена; false в i-той ячейке означает, что i-тая вершина не была посещена. Таким образом, обработав этот вектор следующей функцией:

![alt text](images/image_isconnected.png)

... можно выяснить, связный ли граф.

### Алгоритм для определения числа реберной связности

Для определения числа реберной связности я удалял всевозможные ребра, а потом делал поиск в глубину, чтобы узнать, стал ли граф несвязным. Если граф после удаления ребра становился несвязным, я добавлял в список возможных вариаций несвязных графов количество ребер полученного несвязного графа.

![alt text](images/image_solve.png)

## Тесты программы

### Первый тест:

![alt text](images/image1.jpg)

Мой граф задан списком смежности:

![alt text](images/image2.jpg)

После ввода данных программа выдает количество операций (ради забавы) и ответ:

![alt text](images/image3.jpg)

### Второй тест:

![alt text](images/image4.png)

Консоль:

![alt text](images/image5.png)

### Третий тест:

![alt text](images/image6.png)

![alt text](images/image7.png)

### Четвертый тест:

![alt text](images/image8.png)

![alt text](images/image9.png)

### Пятый тест:

![alt text](images/image10.png)

![alt text](images/image11.png)

# Вывод

В процессе выполнения рассчетной работы я познакомился с такой структурой данных как графы, научился работать с алгоритмом поиска в глубину, а также реализовал  алгоритм определения числа реберной связности.

## Использованные источники:

### Свободная энциклопедия "Википедия"
- https://ru.m.wikipedia.org/wiki/

### Algorithmica:
- https://ru.algorithmica.org/cs/graph-traversals/dfs/
