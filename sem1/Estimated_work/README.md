# Расчетная работа
## Варианты 6.3, 6.4 

### Авторы: Захаренков Иван, Шумилов Артем
#### Гр. 421702

## Содержание

- [*Глоссарий*](#глоссарий)

- [*1 Введение*](#введение)

    - [*1.1 Постановка задачи*](#постановка-задачи)

    - [*1.2 Применение*](#применение)

    - [*1.3 Обзор существующих методов проверки*](#обзор-существующих-методов-проверки)

- [*2 Гамма-алгоритм*](#гамма-алгоритм)

    - [*2.1 Описание алгоритма*](#описание-алгоритма)

        - [*2.1.1 Входные данные*](#входные-данные)

        - [*2.1.2 Инициализация алгоритма*](#инициализация-алгоритма)

        - [*2.1.3 Общий шаг*](#общий-шаг)

        - [*2.1.4 Завершение работы*](#завершение-работы)
        
    - [*2.2 Реализация алгоритма*](#реализация-алгоритма)

- [*3 Выводы*](#выводы)

- [*Список литературы*](#список-литературы)


## Глоссарий

- Граф – это топологичекая модель, которая состоит из множества вершин и множества соединяющих их рёбер. При этом значение имеет только сам факт, какая вершина с какой соединена.

- Смежность – отношение между двумя вершинами, в котором существует ребро их соединяющее.

- Концевые вершины графа - вершины, соединяющие данное множество ребер.

- Мост - ребро, после удаления которого, граф распадается на две компоненты связности. 

- Планарность - свойство графа, которое возникает, если существует укладка взятого графа на плоскости.

- Плоский граф - граф, изображенный на плоскости так, что никакие два ребра не имеют общих точек, кроме инцидентной им обоим вершины.

- Подграф - это часть графа, в которой мы берем некоторые его вершины и ребра. Другими словами, граф H является подграфом графа G, если вершины и ребра H являются подмножеством вершин и ребер G.

- Связный граф - граф, содержащий ровно одну компоненту связности. Это означает, что между любой парой вершин этого графа существует как минимум один путь.

- Сегмент - компонент связности графа с его подграфом.

- Укладка графа - такое его геометрическое изображение, при котором ребра графа пересекаются только в вершинах.


## Введение
### Постановка задачи
Реализовать алгоритм проверки графа на планарность и приведения его к планарному виду путем удаления наименьшего количества вершин или ребер, если он таковым не является

### Применение 
Примером применения данного алгоритма может послужить проблема изготовления электронных микросхем. Электрические цепи печатным способом наносятся на плату из изолирующего материала. Так как наносимые цепи не изолированы, то они не должны пересекаться. В контексте данной проблемы, важно решить, как расположить контакты на схеме, чтобы можно было без пересечений нанести цепи на плату. 

### Обзор существующих методов проверки
1. Теорема Понтрягина-Куратовского - доказывает, что граф планарен тогда и только тогда, когда он не содержит подграфов, гомеоморфных K5 или K3,3. Так как этот критерий очень трудно проверить на практике, данная теорема представляет лишь теоретический интерес.
2. Гамма алгоритм – алгоритм, основанный на теореме Понтрягина-Куратовского, с помощью которого удобнее всего проверить граф на планарность и уложить его на плоскости. 
3. Алгоритм Тарьяна-Хопкрофта – алгоритм который проверяет граф на планарность и в зависимости от результата проверки также укладывает его на плоскости

## Гамма-алгоритм
Одним из варинатов, чтобы проверить планарность графа и произвести его плоскую укладку является гамма-алгоритм. Он был подробно описан Ириневым Антоном и Кашириным Виктором в работе под названием “Алгоритм плоской укладки графов”. 

### Описание-алгоритма
#### Входные данные
На вход алгоритму подаются графы со следующими свойствами:
1.	Граф связный.
> Если нарушено свойство, то граф нужно укладывать отдельно по компонентам связности. 

2.	Граф содержит хотя бы один цикл.
> Если нарушено свойство , то граф — дерево и нарисовать его плоскую укладку тривиально.

3.	Граф не имеет мостов.
> Случай нарушения данного свойства рассмотрим более подробно. Если в графе есть мосты, то их нужно разрезать, провести отдельно плоскую укладку каждой компоненты связности, а затем соединить их мостами. Здесь может возникнуть трудность: в процессе укладки концевые вершины моста могут оказаться внутри плоского графа. Нарисуем одну компоненту связности, и будем присоединять к ней другие последовательно. Каждую новую компоненту связности будем рисовать в той грани, в которой лежит концевая вершина соответствующего моста. Так как граф связности мостами компонент связности является деревом, мы сумеем получить плоскую укладку.

**Замечание.** Если концевая вершина, принадлежащая новой (только что нарисованной) компоненте связности, также оказалась внутри, необходимо выполнить повторную укладку этой компоненты так, чтобы ребро, содержащее концевую вершину, принадлежало внешней грани.

#### Инициализация алгоритма

Пусть дан граф G (см. рис. 1):

<p align="center">
<image
  src="images/original_graph.svg"
  caption="Исходный граф"
  style="width: 400px;">
  <p align="center">Рис. 1</p>
</p>

Выбираем любой простой цикл в G, пусть это будет {1, 2, 3, 4, 5, 6}, укладываем его на плоскости, и получаем две грани: Г1 — внешнюю и Г2 — внутреннюю (см. рис. 2).

<p align="center">
<image
  src="images/find_cycle.svg"
  style="width: 400px;">
  <p align="center">Рис. 2</p>
</p>

Уже уложенную часть исходного графа будем обозначать как G′, тогда после первого шага G′ представляет собой цикл {1, 2, 3, 4, 5, 6}.

На каждом шаге будем строить множество сегментов. Каждый сегмент S относительно уже построенного графа G′ представляет собой одно из двух:

- ребро, оба конца которого принадлежат G′, но само оно не принадлежит G′;
- связную компоненту графа G – G′, дополненную всеми ребрами графа G, один из концов которых принадлежит связной компоненте, а второй из графа G′.

Вершины, которые одновременно принадлежат G′ и какому-то сегменту, назовем контактными вершинами. Для нашего примера сегменты изображены на рис. 3. Контактные вершины обведены в квадрат.

<p align="center">
<image
  src="images/find_segments.svg"
  style="width: 500px;">
  <p align="center">Рис. 3</p>
</p>

Если бы в каком-нибудь сегменте не было ни одной контактной вершины, то граф до построения множества сегментов был бы несвязный; если бы была только одна контактная вершина, то граф имел бы мост. Эти возможности заранее исключены, так что каждый сегмент имеет не менее двух контактных вершин. Поэтому в каждом сегменте имеется цепь между любой парой таких вершин.

Если все контактные вершины сегмента S имеют номера вершин какой-то грани Г, то мы будем говорить, что грань Г вмещает этот сегмент, в этом случае будем использовать следующее обозначение: S Г. Однако, может быть так, что не одна грань вмещает в себя сегмент S, а несколько. Множество таких граней обозначим Г(S), а их число |Г(S)|.

#### Общий шаг 
Выделяются все сегменты Si и определяются числа |Г(Si)|. Если хоть одно из них равно 0, то граф не планарен, конец. Иначе, выбираем сегмент, для которого число |Г(S)| минимально, или любой из них, если таких сегментов несколько. В этом сегменте найдем произвольную цепь между двумя контактными вершинами и уложим ее в любую из граней множества Г(S). При этом данная грань разобьется на две. Уже уложенная часть графа G’ после укладки цепи увеличится, а сегмент, из которого вынута цепь, исчезнет или развалится на меньшие с новыми контактными вершинами, ведущими к вершинам G′.

В результате повторения общего шага будет либо получена плоская укладка, когда множество сегментов станет пустым, либо будет получено, что граф G не является планарным.

Вернемся к нашему примеру. Пока для любого i: Si {Г1, Г2}, |Г(Si)| = 2. Поэтому возьмем первый по номеру сегмент Si и в нем цепь {1, 4}; вставим эту цепь в грань Г2. После укладки цепи G’ увеличится и произойдут изменения в структуре сегментов (см. рис. 4, 5).

<p align="center">
<image
  src="images/1_segment _aid.svg"
  style="width: 400px;">
  <p align="center">Рис. 4</p>
</p>

<p align="center">
<image
  src="images/4_segment.svg"
  style="width: 400px;">
  <p align="center">Рис. 5</p>
</p>

Определим, какие грани вмещают новые сегменты. Теперь сегменты S1 и S3 можно уложить только в одну грань Г1, в то время как сегменты S2 и S4 можно уложить в две грани (для S2 это грани Г1 и Г2, для S4 - Г1 и Г3). Поэтому берем S1. Возьмем в нем цепь {2, 5} и уложим ее в Г1. Получим увеличенный граф G′ и уменьшенную систему сегментов (см. рис. 6, 7).

<p align="center">
<image
  src="images/2_segment_laid.svg"
  style="width: 420px;">
  <p align="center">Рис. 6</p>
</p>

<p align="center">
<image
  src="images/3_segment.svg"
  style="width: 300px;">
  <p align="center">Рис. 7</p>
</p>


### Завершение работы

Продолжая таким образом, в итоге получим плоскую укладку исходного графа G(см. рис. 8).

<p align="center">
<image
  src="images/embedding_graph.svg"
  style="width: 450px;">
  <p align="center">Рис. 8</p>
</p>

## Реализация алгоритма

На вход нашему алгоритму мы подаем двоичную матрицу смежности, в которой указано количество вершин и их связи.
```cpp
    5
    0 1 1 0 1
    1 0 1 1 0
    1 1 0 1 0
    0 1 1 0 1
    1 0 0 1 0
```

Работа алгоритма начинается с поиска простого цикла, если таких циклов несколько, то берется первый найденный, который ещё не уложен на плоскости. Скорость поиска цикла, так как мы проходим через каждую вершину не более 1 раза занимает не более О(V), где V — количество вершин.


```cpp
    bool findCycle (vector <int>* result, vector<int> used, int parent, int v) {
        used.resize(n, 0);
        used[v] = 1;
        for (int i = 0; i < n; i++) {
            if (i == parent) continue;
            if (matrix[v][i] == 0) continue;
            if (used[i] == 0) {
                result->push_back(v);
                if (findCycle(result, used, v, i)) {
                    //cycle was found
                    return true;
                }
                else {
                    result->pop_back();
                }
            }
            if (used[i] == 1) {
                result->push_back(v);
                auto cycle = new vector <int>;
                for (int j = 0; j < result->size(); j++) {
                    if ((*result)[j] == i) {
                        for (int k = j; k < result->size(); k++) {
                            (*cycle).push_back((*result)[k]);
                        }
                        result->clear();
                        for (int & l : *cycle) {
                            result->push_back(l);
                        }
                        return true;
                        }
                    }
                return true;
                }
        }
        used[v] = 2;
        return false;
    }
```
Так как укладка графа должна быть плоской и все вершины и ребра обязаны присутствовать на выходе, необходимо проверять что еще не расположено на плоскости, т.е. найти все сегменты графа. Для удобного поиска в данной реализации используется алгоритм обхода в глубину. Временная сложность алгоритма поиска в глубину представлена в виде O(V + E), где V — количество вершин, а E — количество ребер.
    
```cpp
    void dfsSegments(vector <int> used, vector<bool>* laidVertexes, Graph* result, int v) {
        used[v] = 1;
        for (int i = 0; i < n; i++) {
            if (matrix[v][i]==1){
                result->NewEdge(v,i);
                if (used[i] == 0 && !(*laidVertexes)[i]) dfsSegments(used, laidVertexes, result, i);
            }
        }
    }
```
В последующем алгоритм должен будет хранить данные о всех построенных гранях, уложенных и неуложенных сегментах и на основе этого формировать планарную укладку входного графа.

В результате, на выходе в консоли у нас будет выводится: 
- информация о том, какие вершины связанны, 
- является ли введенный граф планарным, 
- какое кол-во вершин и ребер нужно удалить для приведения его к планарному виду.

```cpp
    //Пример выходных данных в консоли
    Graph:
    0 -- 1;
    0 -- 4;
    0 -- 5;
    1 -- 2;
    1 -- 6;
    2 -- 3;
    2 -- 7;
    3 -- 4;
    3 -- 8;
    4 -- 9;
    5 -- 7;
    5 -- 8;
    6 -- 8;

    Graph is not planar. To make this graph planar we should delete edges or vertices
    Amount of deleted edges: 1
    Amount of deleted verticies: 1
```    
    
## Тестирование

Для проверки корректности работы алгоритма, используется визуализатор написанный через [graphviz](https://graphviz.org) на языке [DOT](https://graphviz.org/doc/info/lang.html). Задача визуализирующей программы показать, возможна ли укладка планарного графа на основе входных граней.
    
<p align="center">
<image
  src="images/graphviz.png"
  alt="2"
  style="width: 450px;">
  <p align="center">Результат работы взуализатора</p>
</p>
    

## Выводы
В результате проведённой работы удалось:

- Изучить материалы по методам:
    - проверки графа на планарность, 
    - приведения его к планарному виду,
    - укладки его на плоскость
- Выбрать алгоритм решения данной задачи и реализовать на языке С++


## Список литературы
1. [Гамма-алгоритм. Викиконспекты](https://neerc.ifmo.ru/wiki/index.php?title=%D0%93%D0%B0%D0%BC%D0%BC%D0%B0-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC)
2. [Алгоритм укладки графа на плоскость](https://studfile.net/preview/2626943/page:6/)
3. [Что такое гамма-алгоритм](https://dic.academic.ru/dic.nsf/ruwiki/628470)
4. [Критерии планарности](https://studfile.net/preview/9024457/page:4/)
5. [Проверка планарности](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B2%D0%B5%D1%80%D0%BA%D0%B0_%D0%BF%D0%BB%D0%B0%D0%BD%D0%B0%D1%80%D0%BD%D0%BE%D1%81%D1%82%D0%B8)
6. [Планарный граф](https://ru.wikipedia.org/wiki/%D0%9F%D0%BB%D0%B0%D0%BD%D0%B0%D1%80%D0%BD%D1%8B%D0%B9_%D0%B3%D1%80%D0%B0%D1%84)
7. [Теорема Понтрягина-Куратовского](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_%D0%9F%D0%BE%D0%BD%D1%82%D1%80%D1%8F%D0%B3%D0%B8%D0%BD%D0%B0_%E2%80%94_%D0%9A%D1%83%D1%80%D0%B0%D1%82%D0%BE%D0%B2%D1%81%D0%BA%D0%BE%D0%B3%D0%BE)
8. [Теория графов. Термины и определения в картинках](https://habr.com/ru/companies/otus/articles/568026/)

## Pepe
![pepe](https://i.pinimg.com/originals/26/36/7b/26367b882196bab0348c173ec61d9268.gif)
