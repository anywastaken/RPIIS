<h1 align= "center"> Рассчетная работа</h1>  
Работа с графами  
Цель: Научиться работать с графами. Найти граф каркасов для неориентированного графа  
Ключевые понятия:

Граф 

~~~
graph = [
    [0, 2, 0, 6, 0],  # Вершина 0 соединена с вершинами 1 (вес 2) и 3 (вес 6)
    [2, 0, 3, 8, 5],  # Вершина 1 соединена с вершинами 0 (вес 2), 2 (вес 3), 3 (вес 8), и 4 (вес 5)
    [0, 3, 0, 0, 7],  # Вершина 2 соединена с вершинами 1 (вес 3) и 4 (вес 7)
    [6, 8, 0, 0, 9],  # Вершина 3 соединена с вершинами 0 (вес 6), 1 (вес 8), и 4 (вес 9)
    [0, 5, 7, 9, 0]   # Вершина 4 соединена с вершинами 1 (вес 5), 2 (вес 7), и 3 (вес 9)
]
~~~

Каркас графа

~~~
[(0, 1), (1, 2), (2, 4), (0, 3)]
~~~

Алгоритм:
~~~
# Функция для выполнения поиска в глубину (DFS)
def dfs(graph, v, visited, parent, tree_edges):
    # Помечаем текущую вершину как посещенную
    visited[v] = True
    
    # Итерируем по всем возможным вершинам (по соседям текущей вершины)
    for i in range(len(graph)):
        # Если существует ребро между вершинами v и i, и вершина i еще не была посещена
        if graph[v][i] != 0 and not visited[i]:
            # Устанавливаем родителя вершины i (вершина v будет родителем для вершины i)
            parent[i] = v
            
            # Добавляем ребро (v, i) в список рёбер каркаса
            tree_edges.append((v, i))
            
            # Рекурсивно вызываем dfs для соседней вершины i
            dfs(graph, i, visited, parent, tree_edges)

# Функция для нахождения каркаса графа
def find_spanning_tree(graph):
    V = len(graph)  # Количество вершин в графе
    visited = [False] * V  # Массив посещенных вершин, изначально все вершины не посещены
    parent = [-1] * V  # Массив родителей для каждой вершины, изначально все значения -1 (нет родителя)
    tree_edges = []  # Список рёбер, которые будут образовывать каркас графа

    # Стартуем с вершины 0 (можно выбрать любую вершину)
    dfs(graph, 0, visited, parent, tree_edges)
    
    return tree_edges  # Возвращаем список рёбер, которые составляют каркас графа

# Пример графа в виде матрицы смежности
graph = [
    [0, 2, 0, 6, 0],  # Вершина 0 соединена с вершинами 1 (вес 2) и 3 (вес 6)
    [2, 0, 3, 8, 5],  # Вершина 1 соединена с вершинами 0 (вес 2), 2 (вес 3), 3 (вес 8), и 4 (вес 5)
    [0, 3, 0, 0, 7],  # Вершина 2 соединена с вершинами 1 (вес 3) и 4 (вес 7)
    [6, 8, 0, 0, 9],  # Вершина 3 соединена с вершинами 0 (вес 6), 1 (вес 8), и 4 (вес 9)
    [0, 5, 7, 9, 0]   # Вершина 4 соединена с вершинами 1 (вес 5), 2 (вес 7), и 3 (вес 9)
]

# Получаем каркас графа, используя функцию find_spanning_tree
tree_edges = find_spanning_tree(graph)

# Выводим рёбра каркаса
print("Рёбра каркаса:")
for edge in tree_edges:
    print(edge)
~~~

Алгоритм нахождения всех каркасов графа:  
Инициализация:

У нас есть граф, представленный в виде матрицы смежности, где рёбра между вершинами представлены их весами. Если значения в ячейке матрицы равны 0, значит, между соответствующими вершинами нет ребра.
Мы создаём массив visited, который будет отслеживать, какие вершины были посещены во время обхода графа.
Также создаём массив parent, который хранит информацию о родительской вершине для каждой вершины (то есть, откуда мы пришли в эту вершину).
Создаём пустой список tree_edges, в который будут добавляться рёбра, составляющие каркас (остовное дерево) графа.
Запуск DFS:

Начинаем обход графа с произвольной вершины (например, с вершины 0).
Для каждой вершины выполняем следующие шаги:
Помечаем текущую вершину как посещённую, чтобы не попасть в бесконечный цикл, если граф имеет циклы.
Проходим по всем возможным соседям этой вершины. Если существует ребро (в матрице смежности есть ненулевое значение) и соседняя вершина ещё не была посещена:
Добавляем это ребро в список рёбер, составляющих каркас.
Помечаем соседнюю вершину как посещённую.
Рекурсивно вызываем DFS для этой соседней вершины (то есть, продолжаем обход).
Завершение обхода:

Когда все вершины будут посещены и все возможные рёбра будут обработаны, алгоритм завершит свою работу.
В списке tree_edges будут храниться рёбра, которые соединяют все вершины, образуя каркас (остовное дерево).
Результат:

После завершения алгоритма, список tree_edges будет содержать все рёбра, которые составляют каркас графа, то есть подмножество рёбер, которое соединяет все вершины без циклов.  
Источники:
"Алгоритмы: построение и анализ" (авторы: Томас Х. Кормен, Чарльз Э. Лейзерсон, Рональд Л. Ривест, Клиффорд Стайн) — Это один из самых известных учебников по алгоритмам, где подробно рассматриваются структуры данных и алгоритмы на графах, включая поиск в глубину, минимальные остовные деревья и другие основные алгоритмы.
"Структуры данных и алгоритмы на языке программирования C++" (автор: Михаил Лаврентьев) — Книга, в которой рассматриваются различные структуры данных и алгоритмы, в том числе и на графах.
GeeksforGeeks (https://www.geeksforgeeks.org) 
Wikipedia (https://en.wikipedia.org/wiki/Depth-first_search)
