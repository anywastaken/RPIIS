# Функция для выполнения поиска в глубину (DFS)
def dfs(graph, v, visited, parent, tree_edges):
    # Помечаем текущую вершину как посещенную
    visited[v] = True
    
    # Итерируем по всем возможным вершинам (по соседям текущей вершины)
    for i in range(len(graph)):
        # Если существует ребро между вершинами v и i, и вершина i еще не была посещена
        if graph[v][i] != 0 and not visited[i]:
            # Устанавливаем родителя вершины i (вершина v будет родителем для вершины i)
            parent[i] = v
            
            # Добавляем ребро (v, i) в список рёбер каркаса
            tree_edges.append((v, i))
            
            # Рекурсивно вызываем dfs для соседней вершины i
            dfs(graph, i, visited, parent, tree_edges)

# Функция для нахождения каркаса графа
def find_spanning_tree(graph):
    V = len(graph)  # Количество вершин в графе
    visited = [False] * V  # Массив посещенных вершин, изначально все вершины не посещены
    parent = [-1] * V  # Массив родителей для каждой вершины, изначально все значения -1 (нет родителя)
    tree_edges = []  # Список рёбер, которые будут образовывать каркас графа

    # Стартуем с вершины 0 (можно выбрать любую вершину)
    dfs(graph, 0, visited, parent, tree_edges)
    
    return tree_edges  # Возвращаем список рёбер, которые составляют каркас графа

# Пример графа в виде матрицы смежности
graph = [
    [0, 2, 0, 6, 0],  # Вершина 0 соединена с вершинами 1 (вес 2) и 3 (вес 6)
    [2, 0, 3, 8, 5],  # Вершина 1 соединена с вершинами 0 (вес 2), 2 (вес 3), 3 (вес 8), и 4 (вес 5)
    [0, 3, 0, 0, 7],  # Вершина 2 соединена с вершинами 1 (вес 3) и 4 (вес 7)
    [6, 8, 0, 0, 9],  # Вершина 3 соединена с вершинами 0 (вес 6), 1 (вес 8), и 4 (вес 9)
    [0, 5, 7, 9, 0]   # Вершина 4 соединена с вершинами 1 (вес 5), 2 (вес 7), и 3 (вес 9)
]

# Получаем каркас графа, используя функцию find_spanning_tree
tree_edges = find_spanning_tree(graph)

# Выводим рёбра каркаса
print("Рёбра каркаса:")
for edge in tree_edges:
    print(edge)
