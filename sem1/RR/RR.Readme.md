# <a href="https://git.io/typing-svg"><img src="https://readme-typing-svg.herokuapp.com?font=Italic&weight=500&size=33&pause=1000&color=D740F7&random=false&width=435&lines=%D0%A0%D0%B0%D1%81%D1%87%D0%B5%D1%82%D0%BD%D0%B0%D1%8F+%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0" alt="Typing SVG" /></a>
---
## Введение

### Цель
♥ Изучить основы теории графов, способы представления графов, базовые алгоритмы для работы с графам. ♥

---
### Задание
>*☆ 1.8 определить вид графа ☆*

Реализовать на С++ код, определяющий двусвязный граф. Граф представлен в виде матрицы инцидентности.

---
### Ключевые понятия 

* $\color{violet}{\textsf {Граф }}$  -  математическая абстракция реальной системы любой природы, объекты которой обладают парными связями.
(совокупность точек, соединенных линиями. Точки называются вершинами, или узлами, а линии – ребрами, или дугами.)

* $\color{violet}{\textsf{ Неориентированный граф }}$ — Граф, ни одному ребру которого не присвоено направление.

* $\color{violet}{\textsf{ Матрица инцедентности графа }}$ — это матрица, количество строк в которой соответствует числу вершин, а количество столбцов – числу рёбер. В ней указываются связи между инцидентными элементами графа (ребро(дуга) и вершина). (В неориентированном графе если вершина инцидентна ребру то соответствующий элемент равен 1, в противном случае элемент равен 0)

* $\color{violet}{\textsf{ Двусвязный граф }}$ - связный и неделимый граф в том смысле, что удаление любой вершины не приведёт к потере связности.

## Решение

На вход алгоритму подаётся матрица инцидентности. По ней необходимо проверить, инцидентна ли каждая вершина как минимум двум рёбрам. 

* Разбор кода
- `Если файл не удалось найти, выводим в консоль сообщение об ошибке`
```C++
if (!fin.is_open())
{
	cout << "Файл не найлен\n";
}
```

- `Последующий код оборачиваем в условие else`

- `Создаём переменную для счёта количества символов и временную переменную. Пока файл не проверен до конца, записываем символ во временную переменную и увеличиваем счётчик символов`
```C++
int count = 0;
int temp;

while (!fin.eof())
{
    fin >> temp;
    count++;
}
```

- `Переходим обратно в начало файла`
```C++
fin.seekg(0, ios::beg);
fin.clear();
```

- `Создаём переменную для счёта количества пробелов и для символов. Пока файл не проверен до конца, получаем символ. Если этот символ - пробел, то увеличиваем счётчик пробелов. Если доходим до конца строки, то выходим из цикла`
```C++
int count_space = 0;
char symbol;
while (!fin.eof())
{           
    fin.get(symbol);
    if (symbol == ' ') 
        count_space++;
    if (symbol == '\n')
        break;
}
```

- `Снова возвращаемся в начало файла`
```C++
fin.seekg(0, ios::beg);
fin.clear();
```

- `Создаём переменные и вычисляем количество строк и столбцов`
```C++
int rows = count / (count_space + 1);
int columns = count_space + 1;
```

- `Создаём двумерный динамческий массив`
```C++
double** matrix;
matrix = new double* [rows];
for (int i = 0; i < rows; i++)
    matrix[i] = new double[columns];
```

- `Записываем в этот массив данные из матрицы`
```C++
for (int i = 0; i < rows; i++)
    for (int j = 0; j < columns; j++)
        fin >> matrix[i][j];
```

- `Выводим матрицу на экран`
```C++
for (int i = 0; i < rows; i++)
{
    for (int j = 0; j < columns; j++)
        cout << matrix[i][j] << "\t";
    cout << "\n";
}
```

- `Создаём переменную, где будет записан ответ, является ли граф двусвязным`
```C++
bool check2sv = true;
```

- `Выполняем проверку на двусвязность. Если встречаем в строке матрицы единицу, то увеличиваем переменную count1. Если в строке меньше двух единиц, то записываем в check2sv значение false`
```C++
for (int i = 0; i < rows; i++) 
{
    int count1 = 0;
    for (int j = 0; j < columns; j++)
    {
        if (matrix[i][j] == 1)
        {
            count1++;                   
        }
        
    }
    if (count1 < 2) {
        
        check2sv = false;
    }
}
```

- `Выводим на экран результат. Если check2sv не было изменено на false, то граф двусвязный. В ином случае граф не двусвязный`
```C++
if (check2sv != false)
{
    cout << "Граф двусвязный\n";
}
else
{
    cout << "Граф не двусвязный\n";
}
```

- `Очищаем память, удаляя двумерный массив и закрывая файл` 
```C++
for (int i = 0; i < rows; i++)
    delete[] matrix[i];
delete[] matrix;

fin.close();
```

## Тесты:
Граф 1:


![граф1](https://github.com/user-attachments/assets/b15e885b-73a1-44c0-aec5-35fa6f505e56)


Матрица 1:
```
1 0 1 0
1 1 0 0
0 1 0 1
0 0 1 1
```

Результат 1:

![Screenshot 2024-12-19 220720](https://github.com/user-attachments/assets/5325bb83-af2e-4644-910d-22415547e514)


Граф 2:

![граф2](https://github.com/user-attachments/assets/45ea1d76-fa35-4193-a149-0bb8caedeac4)

Матрица 2:
```
1 0 1 0 0 0 0 1 0
1 1 0 0 1 0 0 0 1
0 1 0 1 0 1 0 0 0
0 0 1 1 0 0 1 0 0
0 0 0 0 0 0 0 1 1
0 0 0 0 1 1 1 0 0
```

Результат 2:

![Screenshot 2024-12-19 220601](https://github.com/user-attachments/assets/9dad1f3e-5204-4099-85a9-da4b5c35730a)


Граф 3:

![Граф3](https://github.com/iis-32170x/RPIIS/blob/Давыдов_Р/RR/Tests/graph3.PNG)

$\color{light_blue}{\textsf { Матрица 3: }}$
```
1 1 0 1
1 0 1 0
0 1 1 0
0 0 0 1
```

Результат 3:

![Screenshot 2024-12-19 220831](https://github.com/user-attachments/assets/88db7138-180d-4596-8056-1f1182b4d343)


## Выводы
В результате выполнения расчётной работы приобрёл следующие навыки:

* $\color{violet}{\textsf { Изучил основы теории графов }}$

* $\color{violet}{\textsf { Изучил способы представления графов }}$

* $\color{violet}{\textsf { Изучил базовые алгоритмы для работы с графами }}$

* $\color{violet}{\textsf { Изучил базовые алгоритмы работы с файлами в C++ }}$
