# Расчетная работа 

## Введение

### Цели: 
научится работать с графами, создавать программы определяющие виды графов

### Задача: 
Найти дерево кратчайших путей

### Вариант: 
5.29 матрица смежности

### Определения:

`Матрица смежности` — таблица, где как столбцы, так и строки соответствуют вершинам графа. В каждой ячейке этой матрицы записывается число, определяющее наличие связи от вершины-строки к вершине-столбцу (либо наоборот).

`Граф` — математическая абстракция реальной системы любой природы, объекты которой обладают парными связями. Граф как математический объект есть совокупность двух множеств — множества самих объектов, называемого множеством вершин, и множества их парных связей, называемого множеством рёбер. Элемент множества рёбер есть пара элементов множества вершин.

`Ориентированный граф` — граф, рёбра которого имеют направление, в отличие от неориетированного графа.

`Взвешенный граф` — граф, каждому ребру которого поставлено в соответствие некое значение (вес ребра).
 
### Алгоритм:
1.  Выбрать файл с матрицей смежности и открыть его или ввести матрицу смежности с клавиатуры
2.  Проверить совпадает ли количество строк и столбцов в матрице, если она была открыта из файла
3. Заполнить матрицу полученными данными
4. Выбрать начальную вершину
5. Проверить взвешенность и ориентированность графа
6. Вывести на экран выводы об ориетированности и взвешенности графа и матрицу смежности
7. Подсчитать кратчайшие пути:
  1) Записать путь от вершину начала к смежным вершинам
  2) Взять вершину путь к которой уже подсчитан
  3) Проверить будет ли сумма пути до этой вершины и от этой к смежной ей вершине короче уже записаного пути к этой смежной вершине. Если нет, пропустить пункт 4)
  4) Перезаписать новый путь к этой смежной вершине
  5) Повторить для остальных точек необходимое количество раз
8. Вывести полученные расстояния до вершин и пути к ним
 ## Код программы:
```cpp
#include <iostream>
#include <vector>

using namespace std;

bool isBerzhGraph(int n, const vector<vector<int>>& adjList)
{
    // Проверяем, есть ли петли или многократные рёбра
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < adjList[i].size(); j++)
        {
            int u = adjList[i][j];

            // Проверка на петли (ребра, соединяющие вершину с самой собой)
            if (u == i)
            {
                return false; // Граф не является графом Бержа
            }

            // Проверка на многократные рёбра
            for (int k = j + 1; k < adjList[i].size(); k++)
            {
                if (adjList[i][k] == u)
                {
                    return false; // Граф не является графом Бержа
                }
            }
        }
    }

    return true; // Граф является графом Бержа
}

int main()
{
    setlocale(LC_ALL, "Russian");

    int n, m;

    // Ввод количества вершин и рёбер
    cout << "Введите количество вершин (n) и рёбер (m): ";
    cin >> n >> m;

    // Проверка ввода n и m
    if (cin.fail() || n <= 0 || m < 0)
    {
        cout << "Ошибка ввода! Количество вершин и рёбер должно быть положительным." << endl;
        return 1;
    }

    // Проверка на избыточное количество рёбер
    if (m > n * (n - 1) / 2)
    {
        cout << "Ошибка: количество рёбер превышает максимально допустимое для простого графа." << endl;
        return 1;
    }

    // Список смежности
    vector<vector<int>> adjList(n);

    cout << "Введите рёбра (двухсторонние (u, v), вершины нумеруются с 0 до " << n - 1 << "):" << endl;

    for (int i = 0; i < m; i++)
    {
        int u, v;
        cin >> u >> v;

        // Проверка ввода вершин
        if (cin.fail() || u < 0 || u >= n || v < 0 || v >= n)
        {
            cout << "Ошибка ввода! Вершины должны быть в диапазоне от 0 до " << n - 1 << "." << endl;
            return 1;
        }

        // Проверка на петлю
        if (u == v)
        {
            cout << "Ошибка: петли (ребра вида " << u << " -> " << v << ") недопустимы для графа Бержа." << endl;
            return 1;
        }

        // Проверка на многократные рёбра вручную
        bool duplicate = false;
        for (int x : adjList[u])
        {
            if (x == v)
            {
                duplicate = true;
                break;
            }
        }
        if (duplicate)
        {
            cout << "Ошибка: ребро между вершинами " << u << " и " << v << " уже существует." << endl;
            return 1;
        }

        // Добавляем ребро в список смежности
        adjList[u].push_back(v);
        adjList[v].push_back(u);
    }

    // Определяем, является ли граф графом Бержа
    if (isBerzhGraph(n, adjList))
    {
        cout << "Граф является графом Бержа." << endl;
    }
    else
    {
        cout << "Граф не является графом Бержа." << endl;
    }

    return 0;
}

```

  
 ## Вывод
 В результате выполнения данной работы были получены следующие практические навыки:
 
изучены основы теории графов

изучены способы представления графов

изучены базовые алгоритмы для работы с графами
