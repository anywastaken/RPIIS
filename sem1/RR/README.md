# Расчётная работа
## Цели
- Ознакомиться с основами теории графов
- Реализовать граф в языке программирования C++
- Реализовать алгоритм решения задачи с графами по вариантам
## Вариант расчётной работы
* Мой вариант был **1.21**(Планарный граф) мс *(матрица смежности)* нг *(неориентированный граф)* в [Руководстве к расчётной работы](https://drive.google.com/drive/folders/19HJwkGGA-ZhebpaelsZvrmV5ZuwKclkh)
## Теоретические сведения
* **Граф** - это топологичекая модель, которая состоит из множества вершин и множества соединяющих их рёбер. При этом значение имеет только сам факт, какая вершина с какой соединена.
* **Матрица смежности** - это один из способов представления графа квадратной матрицей, размер которой определяется числом вершин графа, а элементы матрицы определяют наличие ребра между вершинами *(1 - есть ребро, 0 - нет ребра)*
* **Неориентированный граф** - это такой граф, в котором все связки являются ребрами *или* это такой граф в котором ребра не указывают определенное направление.
* **Планарный граф** - это такой граф, который  можно так изобразить на плоскости, что никакие два ребра, за исключением, выходящих из общей вершины, не имеют общих точек (то есть не пересекаются).\
## Пример планарного графа
![4вершинный планарный граф]()
## Пример непланарных графов
* Теорема Понтрягина — Куратовского\
Теорема утверждает, что графы **K5** *(полный граф на 5 вершинах)* и **K3,3** *(полный двудольный граф имеющий по 3 вершины в каждой доле)* являются единственными минимальными непланарными графами.\
Также из теоремы следует, что если граф содержит подграф К5 или К3,3, то он **непланарный**.\
![Непланарные графы К5, К3,3]()
## Алгоритмы проверки графов на планарность
1) Метод добавления пути(Алгоритм Хопкрофта-Тарьяна)
2) Метод добавления вершин
3) Метод добавления рёбер
4) Метод последовательного построения
## Выполнение расчётной работы
## Задание графа матрицей смежности на С++
```
int input_graph(vector<vector<int>>& matr_adjacency_graph,int count_vert_inp){
    matr_adjacency_graph.resize(count_vert_inp,vector<int>(count_vert_inp));
    for (int i=0; i<count_vert_inp; i++) {
        for (int j=0; j<count_vert_inp; j++) {
            cin >> matr_adjacency_graph[i][j];
            while (matr_adjacency_graph[i][j] !=1 &&matr_adjacency_graph[i][j]!=0) {
                cerr << "Wrong input matrix! Input only 1 or 0!\n";
                exit(1);
            }
        }
    }
    return 0;
}
```
## Пример алгоритма проверки графа на планарность на С++
```
int is_planar_graph(vector<vector<int>>matr_adj,int count_vertex){
    int count_edge=0;
    if(count_vertex<5)cout << "Graph is planar\n";
    if (count_vertex>=5) {
        for (int a=0; a<count_vertex-4; a++) {
            for (int b=0; b<count_vertex-4; b++) {
                for (int i=0; i<5; i++) {
                    for (int j=i+1; j<5; j++) {
                        if (matr_adj[i+a][b+j]==1 && matr_adj[b+j][a+i]==1) {
                            count_edge++;
                        }
                        if (count_edge==10) {
                            cout << "Graph is non-planar\n";
                            return 0;
                        }
                    }
                }
//                cout << k<<" "<<b<<" "<< count_edge<<"\n";
                count_edge=0;
            }
        }
        for (int x=0; x<count_vertex-5; x++) {
            for (int y=0; y<count_vertex-5; y++) {
                for (int i=0; i<3; i++) {
                    for (int j=0; j<3; j++) {
                        if (matr_adj[x+5-i][y+j]==1 &&matr_adj[x+i][y+3+j]) {
                            count_edge++;
                            if (count_edge==9) {
                                cout << "Graph is non-planar\n";
                                return 0;
                            }
//                            cout << x<< " "<<y << " "<< count_edge<<"\n";
                        }
                    }
                }
                count_edge=0;
            }
        }
    }
    cout << "Graph is planar\n"<<count_edge;
    
    return 0;
}
```
## Пример выполнения кода
* Пример для графа К5\
Матрица смежности\
```
0 1 1 1 1
1 0 1 1 1
1 1 0 1 1
1 1 1 0 1
1 1 1 1 0
```
![Граф К5]()\
* Пример для графа К3,3\
Матрица смежности\
```
0 0 0 1 1 1
0 0 0 1 1 1
0 0 0 1 1 1
1 1 1 0 0 0
1 1 1 0 0 0
1 1 1 0 0 0
```
![Граф К3,3]()\
* Пример для графа содержащего К3,3\
Матрица смежности\
```
0 0 1 0 1 1 0 1 1 1 
1 0 1 0 1 1 0 1 1 1 
1 0 0 0 1 1 0 1 1 1 
1 0 1 0 1 1 0 1 1 1 
1 0 1 0 0 1 0 1 1 1 
1 0 1 0 1 0 0 1 1 1 
1 0 1 0 1 1 0 1 1 1
1 0 1 0 1 1 1 0 0 0
1 0 1 0 1 1 1 1 0 1
1 0 1 0 1 1 1 1 1 0
```
![Граф содержащий К3,3]()\
* Пример для планарного графа\
Матрица смежности\
```
0 1 0 1 0
1 0 0 1 0
0 0 0 0 0
1 1 0 0 0
0 0 0 0 0
```
![Планарный граф]()\
## Вывод
В результате выполнения рассчетной работы я познакомился и научился работать с такой структурой данных, как графы, а также научился производить объединение графов.
## Полезные источники
* Wikipedia Теория графов [Электронный ресурс]. – Режим доступа: (https://ru.wikipedia.org/wiki/Теория_графов)
* Habr Основы теории графов [Электронный ресурс]. – Режим доступа: (https://habr.com/en/companies/otus/articles/568026/)
* Wikipedia Планарный граф [Электронный ресурс]. – Режим доступа: (https://ru.wikipedia.org/wiki/Планарный_граф)
* Проверка планарности графа [Электронный ресурс]. - Режим доступа: (https://spravochnick.ru/informatika/proverka_planarnosti_grafa/)