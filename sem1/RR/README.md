<h1 align="center">Расчетная работа</h1>

## Цели:
* Изучить основные понятия в теории графов 
* Научиться различать виды графов
* Уметь использовать основные алгоритмы при работе с графами 

## Задачи:
* Выполнить свой вариант расчетной работы
* Перенести получившееся решение на язык программирования С++
* Ознакомиться с основными алгоритмами по работе с графами

## Вариант:
Вариант расчетной работы - 2.5. В данной работе для хранения графов должны быть использованы списки смежности(списки инцидентности). Задача - найти максимальную степень вершины в неориентированном графе.

## Список ключевых понятий 
* **Граф** — математическая абстракция реальной системы любой природы, объекты которой обладают парными связями. Граф как математический объект есть совокупность двух множеств — множества самих объектов, называемого множеством вершин, и множества их парных связей, называемого множеством рёбер.
* **Неориентированный граф** - граф, в котором рёбра не указывают направление. Это значит, что из любой вершины можно попасть в любую точку графа.
* **Степень вершины графа** - количество рёбер графа, инцидентных вершине.


## Основные алгоритмы, которые были использованы при работе

* Список смежности — один из способов представления графа в виде коллекции списков вершин. Каждой вершине графа соответствует список, состоящий из «соседей» этой вершины.
  
 ![graph (7)](https://github.com/iis-42x70x/RPIIS/blob/%D0%93%D0%BE%D1%80%D0%B1%D1%83%D0%BD%D0%BE%D0%B2%D0%B0_%D0%9C/sem1/RR/pic1.jpeg)

  Рассмотрим в качестве примера данный неориентированный граф. Для него список смежности выглядит следующим образом:
  
  ```
  1 2 3
  2 1 4 5
  3 1 5
  4 2 
  5 2 3
  ```
  
  Первый столбец - номера вершин графа. В строке для каждой вершины записаны номера вершин, смежных с данной (то есть, вершин, которые связаны с данной). Например, мы видим, что вершина 4 связана с вершиной 2 ребром, значит, мы запишем во вторую строку это как "4 2".


**Степень вершины**

Степенью вершины неориентированного графа называется количество рёбер графа, инцидентных вершине.
Найдем максимальную степень вершины произвольного неорриентированного графа:

![graph (8)](https://github.com/iis-42x70x/RPIIS/blob/%D0%93%D0%BE%D1%80%D0%B1%D1%83%D0%BD%D0%BE%D0%B2%D0%B0_%D0%9C/sem1/RR/pic1.jpeg)


 Максимальная степень данного графа равна 3 (в вершине 2).

<ins>**Алгоритм Флойда-Уоршелла**</ins>

Алгоритм Флойда-Уоршелла используется для нахождения длины кратчайшего пути между всеми парами вершин во взвешенном графе.
При решении своей задачи я использовала именно его, находила длину кратчайшего пути между всеми вершинами, и наибольшая из них - диаметр графа.

Создаем матрицу dist для хранения расстояний между всеми парами вершин, изначально во все ячейки кладем бесконечность. Устанавливаем расстояние от вершины до самой себя на 0(главная диагональ матрицы).

 ```
  vector<vector<int>> dist(vertexes, vector<int>(vertexes, INF));
  for (int i = 0; i < vertexes; i++) {
      dist[i][i] = 0;
  }
 ```
Далее заполняем матрицу весами ребер на основе входного списка смежности. Проходим по всем вершинам и для каждой из них устанавливаем расстояние межжду вершиной и смежными ей вершинами, равное весу ребра между ними.
 ```
  for (int i = 0; i < vertexes; i++) {
      for (int j = 0; j < adjList[i + 1].size(); j++) {
          dist[i][adjList[i + 1][j].to - 1] = adjList[i + 1][j].weight;
      }
  }
 ```
Проверяем все возможные пути через промежуточную вершину, обозначим ее через p. Если есть более короткий путь от вершины i к вершине j, используя промежуточную вершину p, то обновляется значение в матрице расстояний dist. Проверяем, существует ли путь из вершины i в p и путь от p к j. 
```
  for (int p = 0; p < vertexes; p++){
      for (int i = 0; i < vertexes; i++){
          if (dist[i][p] != INF){
              for (int j = 0; j < vertexes; j++){
                  if (dist[p][j] != INF && dist[i][j] > dist[i][p] + dist[p][j] && i != j){
                      dist[i][j] = dist[i][p] + dist[p][j];
                  }
              }
          }
      }
  }
```

Например, у нас есть такой неориентированный взвешенный граф:

![graph (12)](https://github.com/user-attachments/assets/a1da46df-b9c2-4a76-a255-cbeeff22ca32)

Промежуточная вершина p = 2, 
dist[1][3] (5)>dist[1][2] (3)+dist[2][3] (1)
Тогда обновляем значение: dist[1][3]=3+1=4, это и будет кратчайший путь из вершины 1 в 3.

Таким образом, данный алгоритм эффективно находит кратчайшие пути между всеми парами вершин в графе и использует их для определения диаметра. Этот подход позволяет обрабатывать графы с циклами, корректно вычисляя расстояния. 

## Тестовые примеры
* Рассмотрим тестовый пример номер 1:

  Графическое изображение графа:
  
  ![graph](https://github.com/iis-42x70x/RPIIS/blob/%D0%93%D0%BE%D1%80%D0%B1%D1%83%D0%BD%D0%BE%D0%B2%D0%B0_%D0%9C/sem1/RR/pic1.jpg)

  На входе дан список смежности взвешенного неориентированного графа:
  ```
  0 1
  1 0 2 3 4 5
  2 1 6
  3 1
  4 1 5
  5 1 4 6
  6 2 5
  ```
  
  В первой строке находится информация о количестве вершин и ребер графа. В данном примере - 7 вершин и 8 ребер. Далее идет непосредственно сам список смежности графа. В начале строк записаны номера вершины , а после записан номер вершины, смежной с данной (то есть с той, с которой она соединена). 
  
  Вывод программы:
  
```
Максимальная степень вершины: 5
```

* Рассмотрим тестовый пример номер 2:

  Входные данные:
```
0 1 2 6
1 0 2 3
2 0 1
3 1 4
4 3 5
5 4 6
6 0 5 7
7 6
```

  Графическое изображение графа:
  
  ![graph (1)](https://github.com/iis-42x70x/RPIIS/blob/%D0%93%D0%BE%D1%80%D0%B1%D1%83%D0%BD%D0%BE%D0%B2%D0%B0_%D0%9C/sem1/RR/pic2.jpg)

  Вывод программы:
  
```
Максимальная степень вершины: 3
```

* Рассмотрим тестовый пример номер 3:

  Входные данные:
  ```
  0 1 2 3
  1 0 3
  2 0
  3 0 1
  4 
  ```
  Графическое представление графа:
  
  ![graph (2)](https://github.com/iis-42x70x/RPIIS/blob/%D0%93%D0%BE%D1%80%D0%B1%D1%83%D0%BD%D0%BE%D0%B2%D0%B0_%D0%9C/sem1/RR/pic3.jpg)
  
  Вывод программы:
  
```
Максимальная степень вершины: 3
```

* Рассмотрим тестовый пример номер 4:

  Входные данные:
  ```
  0 1 4
  1 0 2 3 5 
  2 1
  3 1 5
  4 0 5
  5 1 3 4 

  ```
  Графическое представление графа:

  ![graph (5)](https://github.com/iis-42x70x/RPIIS/blob/%D0%93%D0%BE%D1%80%D0%B1%D1%83%D0%BD%D0%BE%D0%B2%D0%B0_%D0%9C/sem1/RR/pic4.jpg)
  
  Вывод программы:
  
```
Максимальная степень вершины: 4
```

* Рассмотрим тестовый пример номер 5:

  Входные данные:
  ```
  0 1 3
  1 0 2
  2 1 3 
  3 0 4
  4 3
  ```
  Графическое представление графа:

  ![graph (6)](https://github.com/iis-42x70x/RPIIS/blob/%D0%93%D0%BE%D1%80%D0%B1%D1%83%D0%BD%D0%BE%D0%B2%D0%B0_%D0%9C/sem1/RR/pic5.jpg)

  Вывод программы:
  
```
Максимальная степень вершины: 2
```

## Вывод

В ходе выполнения данной расчетной работы были изучены основные понятия о графах, о способах их представления(в частности, список смежности графа). Для решения поставленной задачи мною был составлен и записан алгоритм на таком языке программирования, как C++ 

## Список использованной литературы

1. Свободная энциклопедия "Википедия" \[Электронный ресурс\]. – (https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D0%B5%D0%BF%D0%B5%D0%BD%D1%8C_%D0%B2%D0%B5%D1%80%D1%88%D0%B8%D0%BD%D1%8B_(%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D0%B3%D1%80%D0%B0%D1%84%D0%BE%D0%B2))
2. Ютюб  \[Электронный ресурс\]. - (https://www.youtube.com/watch?v=fCfPjm8u89U)
3. Сайт EVILEG.com \[Электронный ресурс\]. - (https://evileg.com/ru/post/502/#header_%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D1%81%D0%BC%D0%B5%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B8_C_++)
4. Сайт prog-cpp.ru \[Электронный ресурс\]. - (https://prog-cpp.ru/data-graph/)
