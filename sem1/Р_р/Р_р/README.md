# Расчётная работа

---

### Цели:
* изучить основные виды графов,
* научиться создавать алгоритмы для обработки графов,
* реализовать алгоритм на языке С++

## Задание:
Создать программу, которая находит число хорд в неориентированном графе. На вход подаётся матрица инцидентности.

### Основные понятия:
***Граф*** — математическая абстракция реальной системы любой природы, объекты которой обладают парными связями. Граф как математический объект есть совокупность двух множеств — множества самих объектов, называемого множеством вершин, и множества их парных связей, называемого множеством рёбер. Элемент множества рёбер есть пара элементов множества вершин.

***Матрица инцидентности*** — одна из форм представления графа, в которой указываются связи между инцидентными элементами графа (ребро(дуга) и вершина). Столбцы матрицы соответствуют ребрам, строки — вершинам. Ненулевое значение в ячейке матрицы указывает связь между вершиной и ребром (их инцидентность).

***Неориентированный граф*** — Граф, ни одному ребру которого не присвоено направление.

***Цикл*** — граф, состоящий из единственного цикла, или, другими словами, некоторого числа вершин, соединённых замкнутой цепью.

***Хордальный граф*** — граф, каждый из циклов которого, имеющих четыре ребра и более, имеет хорду (ребро, соединяющее две вершины цикла, но не являющееся его частью). 

**Пример хордального графа:** 

![Chordal-graph svg](https://github.com/user-attachments/assets/9ea55ef0-0183-4d9e-971c-c233072a4f28)

#### Ввод матрицы инцидентности.
Введём матрицу с помощью вектора векторов:
```
int nodes, edges;
cout << "Введите количество вершин и рёбер: ";
cin >> nodes >> edges;
vector<vector<int>> incidenceMatrix(nodes, vector<int>(edges));
cout << "Введите матрицу инцидентности: ";
for (int i = 0; i < nodes; i++) {
	for (int j = 0; j < edges; j++) {
		cin >> incidenceMatrix[i][j];
	}
}
```
Это матрица инцидентности предыдущего графа.

### Тестовые примеры:

![граф1](https://github.com/user-attachments/assets/71e5d989-bf51-458e-83b8-d7a8f4fecd17)

Матрица 1:
```
1 0 0 0 0 0 0 0 1
1 1 1 1 1 0 0 0 0
0 1 0 0 0 1 0 0 0
0 0 0 0 1 1 1 0 0
0 0 0 1 0 0 1 1 0
0 0 1 0 0 0 0 1 1
```
Вывод программы: Число хорд в неориентированном графе: 3

![Граф2](https://github.com/user-attachments/assets/81597546-85ac-4223-a715-41ed125d0c3d)

Матрица 2:
```
1 0 0 0 0 1 0 0 0
1 1 0 0 0 0 1 1 0
0 1 1 0 0 0 0 0 1
0 0 1 1 0 0 0 0 0
0 0 0 1 1 0 0 1 1
0 0 0 0 1 1 1 0 0
```
Вывод программы: Число хорд в неориентированном графе: 3

![Граф3](https://github.com/user-attachments/assets/1d75f926-d215-4aa0-b94b-f66cf2e8bf32)

Матрица 3:
```
1 0 0 0 0 0 1 0 0 1
1 1 0 0 0 0 0 1 1 0
0 1 1 1 0 0 0 0 0 0
0 0 1 0 1 0 0 0 0 0
0 0 0 1 1 1 1 0 1 0
0 0 0 0 0 1 0 1 0 1
```
Вывод программы: Число хорд в неориентированном графе: 4

![Граф4](https://github.com/user-attachments/assets/ff26be12-8b40-4f39-803b-e6531749099e)

Матрица 4:
```
1 0 0 0 0 0 0 1 1 0 0 0 0 0 0
1 1 0 0 0 0 0 0 0 1 1 1 0 0 0
0 1 1 0 0 0 0 0 0 0 0 0 1 1 1
0 0 1 1 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 1 0 0 0 0 0 0 0 0 0 1
0 0 0 0 1 1 0 0 0 0 0 1 0 1 0
0 0 0 0 0 1 1 0 1 0 1 0 1 0 0
0 0 0 0 0 0 1 1 0 1 0 0 0 0 0
```
Вывод программы: Число хорд в неориентированном графе: 7

### Алгоритм:

#### Последовательность действий такая:
* Ищем все циклы с количеством рёбер 4 и больше,
* Отмечаем рёбра, которые входят в эти циклы,
* Выводим те, которые остались.

*Сначала объявляем вектор векторов для найденных циклов и вектор, в котором будут оставаться не включённые в циклы рёбра:*
```
vector<int> edgeStatus(edges, true);
vector<vector<int>> cycles;
```
Запускаем цикл, который будет идти по всем рёбрам. Далее для рёбер, которые пока не входят ни в один цикл, создаём вектор (цикл). И для самого цикла создаём вектор, с посещёнными рёбрами. Тут же обозначаем текущее ребро. И далее ищем смежные вершины и переходим от ребра к ребру по циклу, пока не наткнёмся на первоначально взятое ребро.
```
for (int i = 0; i < edges; i++) {
	if (edgeStatus[i]) {
		vector<int> cycle;
		int current = i;
		vector<bool> visited(edges, false);
		do {
			int node1 = -1, node2 = -1;
			for (int j = 0; j < nodes; j++) {
				if (incidenceMatrix[j][current] == 1) {
					if (node1 == -1) {
						node1 = j;
					}
					else {
						node2 = j;
						break;
					}
				}
			}
			cycle.push_back(current);
			visited[current] = true;
			edgeStatus[current] = false;
			for (int j = 0; j < edges; j++) {
				if (visited[j]) {
					continue;
				}
				if (incidenceMatrix[node1][j] == 1 || incidenceMatrix[node2][j] == 1) {
					current = j;
					break;
				}
			}
		} while (current != i);
```
Далее проверяем размер цикла, если больше четырёх, добавляем в вектор векторов. После этого выводим циклы из вектора векторов и хорды, (непосещённые рёбра).
### Вывод:
В ходе выполнения данной расчетной работы были изучены основные понятия о графах, о способах их представления(матрица инцидентности графа). Для решения поставленной задачи мною был составлен и записан алгоритм языке программирования C++

---

### Использованные источники:
* Википедия. [Хордальный граф](https://ru.wikipedia.org/wiki/%D0%A5%D0%BE%D1%80%D0%B4%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%B3%D1%80%D0%B0%D1%84)
* [Habr](https://habr.com/ru/companies/otus/articles/568026/)
* [Сайт](https://translated.turbopages.org/proxy_u/en-ru.ru.538d906f-6754244e-1ae5a4af-74722d776562/https/www.geeksforgeeks.org/what-is-chordal-graphs/)
