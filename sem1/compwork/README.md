# Расчётная работа.
## Тема работы
Тема работы - основы теории графов, базовые алгоритмы на графах.
## Цель работы
- Ознакомиться с понятием графа.
- Узнать какие бывают графы.
- Ознакомиться с различными способами представления графов.
- Научиться сотставлять алгоритмы для решения теоретико-графовых задач.
## Задачи
- Необходимо разработать алгоритм и перенести его на язык программирования (в данном случае Python), который решает выданную преподавателем теоретико-графовую задачу и соответствует следующим требованиям:
- Протестировать алгоритм на данных примерах
- Если преподаватель указал определенную структуру данных для представления графа, то в программе должна быть использована именно эта структура данных. (В данном случае МС и МИ)
## Вариант
В данном отчете представлено решение варианта 5.10 Необходимо найти простые разрезы в графе с максимальным весом. Структура представления данных — матрица смежности или матрица инцидентности.
## Список ключевых понятий, использовавшихся при решении задачи
### Основные определения
 - Граф - это топологичекая модель, которая состоит из множества вершин и множества соединяющих их рёбер. При этом значение имеет только сам факт, какая вершина с какой соединена.
 - Графы, как правило, отображаются графически при помощи точек для представления вершин и отрезков, или ломаных, для отображения рёбер между связанными вершинами. Ориентация ребра (в ориентированном графе) отображается при помощи стрелки.
 - Инцидентность - вершина и ребро называются инцидентными, если вершина является для этого ребра концевой. Термин “инцидентность” применим только к вершине и ребру.
 - Граф может быть ориентированным и неориентированным.
    - **Ориентированный граф** (кратко орграф) — граф, рёбрам которого присвоено направление. Направленные рёбра именуются также дугами, а в некоторых источниках и просто рёбрами.
    - Граф, ни одному ребру которого не присвоено направление, называется **неориентированным графом**(неорграфом).
 - Компонента связности - множество таких вершин графа, что между любыми двумя вершинами существует маршрут.
 - Двудо́льный граф или бигра́ф в теории графов — это граф, вершины которого можно разбить на две части так, что каждое ребро соединяет вершину из одной части с вершиной другой части. То есть, между вершинами одной и той же части рёбра отсутствуют.
 - Разрез графа — множество рёбер, образующих двудольный подграф, удаление которых делит граф на две компоненты, которые, в частности, могут быть изолированными узлами. А также линия, проходящая через все рёбра разреза графа.

## Основные алгоритмы на графах, которые были использованы при решениии теоретико-графовой задачи

- **Матрица смежности** — способ представления графа из *N* вершин, в котором граф задается матрицей *N***N*, в которой g\[i\]\[j\] — вес ребра из вершины *i* в вершину *j*.
- **Матрица инцидентности** — одна из форм представления графа, в которой указываются связи между инцидентными элементами графа (ребро(дуга) и вершина). Столбцы матрицы соответствуют ребрам, строки — вершинам. Ненулевое значение в ячейке матрицы указывает связь между вершиной и ребром (их инцидентность).В случае ориентированного графа каждой дуге <x,y> ставится в соответствующем столбце: «вес ребра» в строке вершины x и «-вес ребра» в строке вершины y; если связи между вершиной и ребром нет, то в соответствующую ячейку ставится «0».
- **Обход в ширину** (Поиск в ширину, англ. BFS, Breadth-first search) — один из простейших алгоритмов обхода графа, являющийся основой для многих важных алгоритмов для работы с графами.
- **Полный перебор** (или метод «грубой силы», англ. brute force) — метод решения математических задач. Относится к классу методов поиска решения исчерпыванием всевозможных вариантов[англ.]. Сложность полного перебора зависит от количества всех возможных решений задачи. Если пространство решений очень велико, то полный перебор может не дать результатов в течение нескольких лет или даже столетий.
- ## Алгоритм решения поставленной задачи

- Сложность алгоритма — O(2<sup>V</sup> * (V+E)) времени, где E — кол-во рёбер, V - кол-во вершин.

# Рассмотрим алгоритм подробнее:
``` Python
def max_simple_cut(incidence_matrix=None, adjacency_matrix=None):
    from collections import deque
```
### Мы используем deque, чтобы работать с очередью, которая позволит нам осуществлять обход в ширину (BFS). deque — это расширяемая очередь, которая может быстро добавлять и удалять элементы с обоих концов.


### Преобразование матрицы смежности в матрицу инцидентности (если необходимо)
``` Python
def convert_adjacency_to_incidence(adjacency_matrix):
    V = len(adjacency_matrix)
    edges = []
    for i in range(V):
        for j in range(i + 1, V):
            if adjacency_matrix[i][j] > 0:
                edges.append((i, j, adjacency_matrix[i][j]))
    E = len(edges)
    incidence_matrix = [[0] * E for _ in range(V)]
    for edge_index, (u, v, weight) in enumerate(edges):
        incidence_matrix[u][edge_index] = weight
        incidence_matrix[v][edge_index] = weight
    return incidence_matrix
```
- Конвертирует матрицу смежности в матрицу инцидентности.
- V — количество вершин в графе.
- edges — список для хранения информации об ребрах (пары вершин и вес).
- Для каждой пары вершин i, j в матрице смежности, если связь существует (adjacency_matrix[i][j] > 0), добавляем это ребро в список edges.
- E — количество ребер (равно длине edges).
- incidence_matrix — создается как матрица размера V x E, заполняемая нулями.
- Затем заполняем матрицу инцидентности: если ребро связано с вершиной u и v, то в incidence_matrix[u][edge_index] и incidence_matrix[v][edge_index] добавляем вес ребра.
### Создание списка смежности для удобной работы с графом
``` Python
V = len(incidence_matrix)
E = len(incidence_matrix[0])
adjacency_list = {i: [] for i in range(V)}
for edge in range(E):
    u, v = None, None
    for vertex in range(V):
        if incidence_matrix[vertex][edge] > 0:
            if u is None:
                u = vertex
            else:
                v = vertex
                break
    if u is not None and v is not None:
        adjacency_list[u].append(v)
        adjacency_list[v].append(u)
```
- V — количество вершин, определенное размером матрицы инцидентности.
- E — количество ребер, определенное количеством столбцов в матрице инцидентности.
- adjacency_list — словарь для хранения смежных вершин. Ключи — это номера вершин, а значения — списки, содержащие номера соседних вершин.
- Проходим по всем ребрам (edge из 0 до E-1):
  - Ищем вершины u и v, инцидентные этому ребру.
  - Если найдено две инцидентные вершины (u и v), добавляем v в список смежности u и u в список смежности v.
### Поиск максимального простого сечения
``` Python
max_cut_weight = float('-inf')
best_partition = None

def generate_partitions(V):
    partitions = []
    for i in range(2 ** V):
        partition = []
        for j in range(V):
            partition.append((i >> j) & 1)
        partitions.append(partition)
    return partitions
```
Функция generate_partitions:
- Создает все возможные разделения множества вершин на две группы (S и T), используя побитовые операции.
- 2 ** V — количество возможных комбинаций.
- partition — представляет собой список, в котором 0 означает, что вершина относится к группе S, а 1 — к группе T.
- Заполняем partitions возможными комбинациями битов от 0 до 2^V - 1.
### Обработка каждого разделения
``` Python
for partition in all_partitions:
    S = [i for i in range(V) if partition[i] == 0]
    T = [i for i in range(V) if partition[i] == 1]

    if not (is_connected(S, adjacency_list) and is_connected(T, adjacency_list)):
        continue
```
Разделение на группы S и T:
- S — вершины, которые принадлежат группе 0.
- T — вершины, которые принадлежат группе 1.
- Проверяем, соединены ли группы S и T с помощью функции is_connected.
- Если S и T не соединены, то переход к следующей комбинации разделения.

### Рассчет веса сечения
``` Python
cut_weight = 0
for edge in range(E):
    incident_vertices = [i for i in range(V) if abs(incidence_matrix[i][edge]) > 0]

    if len(incident_vertices) == 2:
        u, v = incident_vertices
        if (u in S and v in T) or (u in T and v in S):
            cut_weight += abs(incidence_matrix[u][edge])
```
Рассчет веса сечения:
- incident_vertices — список вершин, инцидентных ребру edge.
- Если инцидентных вершин две (len(incident_vertices) == 2), то:
- u и v — эти две вершины.
- Проверяем, если вершина u принадлежит группе S, а вершина v группе T (или наоборот), это ребро участвует в сечении.
- Если да, добавляем вес ребра к cut_weight.
### Проверка на лучшее сечение
``` Python
if cut_weight > max_cut_weight:
    max_cut_weight = cut_weight
    best_partition = (S, T)
```
Если текущий cut_weight больше max_cut_weight, обновляем max_cut_weight и best_partition.
## Тестовые примеры
- Рассмотрим первый тестовый пример:
- Число вершин 5

  ![graph1](https://github.com/user-attachments/assets/5ecb5d16-e203-4fc1-b913-d74312f454d3)
```
1
5
0 2 2 0 2
2 0 3 0 0
2 3 0 4 0
0 0 4 0 5
2 0 0 5 0
```
### Вывод 
``` 
Max cut weight: 10
Optimal vertex partition: ([0, 1, 4], [2, 3])
```
- Рассмотрим второй тестовый пример:
- Число вершин 4

![graph3](https://github.com/user-attachments/assets/4712691b-e1f4-4bcd-a8c0-3ba2717c79d4)


```
1
4
0 1 0 0
1 0 2 0
0 2 0 3
0 0 3 0
```
### Вывод 
``` 
Max cut weight: 3
Optimal vertex partition: ([3], [0, 1, 2])
```
- Рассмотрим третий тестовый пример:
- Число вершин 5
- Число ребер 7

![graph2](https://github.com/user-attachments/assets/9a25e959-ae35-40c3-89b3-db6474a5084f)

```
2
5
7
1 4 2 0 0 0 0
1 0 0 0 0 0 2
0 0 0 0 1 3 2
0 0 2 7 1 0 0
0 4 0 7 0 3 0
```
### Вывод 
```
Max cut weight: 14
Optimal vertex partition: ([2, 4], [0, 1, 3])
```

- Рассмотрим четвертый тестовый пример:
- Число вершин 4
- Число ребер 6
  ![graph4](https://github.com/user-attachments/assets/dd1df5dd-f2a0-43e7-a0c7-3d40213adf48)

```
2
4
6
2 6 8 0 0 0
2 0 0 2 0 7
0 0 8 2 7 0
0 6 0 0 7 7
```
### Вывод 
```
Max cut weight: 24
Optimal vertex partition: ([0, 3], [1, 2])
```
## Вывод

В ходе выполнения расчетной работы:

- Было изучено понятие графа, некоторые типы графов, способы представления графа в памяти компьютера.
- Было решено индивидуальное, составлен и записан на языке программирование C++ алгоритм в соответствии с заданными требованиями.
- Алгоритм был проверен на пяти тестовых примерах.

## Список использованных источников

1. Свободная энциклопедия "Википедия" \[Электронный ресурс\]. – Режим доступа: [https://ru.wikipedia.org/wiki/Ориентированный_граф](https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%82%D1%80%D0%B8%D1%86%D0%B0_%D0%B8%D0%BD%D1%86%D0%B8%D0%B4%D0%B5%D0%BD%D1%82%D0%BD%D0%BE%D1%81%D1%82%D0%B8)
2. Свободная энциклопедия "Википедия" \[Электронный ресурс\]. – Режим доступа: [https://ru.wikipedia.org/wiki/Связный_граф#:~:text=Ориентированный%20граф%20называется%20сильно-связным,ровно%20одну%20сильно%20связную%20компоненту.](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%B8%D1%81%D0%BA_%D0%B2_%D0%B3%D0%BB%D1%83%D0%B1%D0%B8%D0%BD%D1%83)
3. Свободная энциклопедия "Википедия" \[Электронный ресурс\]. – Режим доступа: [https://ru.wikipedia.org/wiki/Компонента_сильной_связности](https://ru.wikipedia.org/wiki/%D0%A1%D0%B2%D1%8F%D0%B7%D0%BD%D1%8B%D0%B9_%D0%B3%D1%80%D0%B0%D1%84)
4. Свободная энциклопедия "Википедия" \[Электронный ресурс\]. – Режим доступа: [https://ru.wikipedia.org/wiki/Граф_(математика)#Обобщение_понятия_графа](https://ru.wikipedia.org/wiki/%D0%9E%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9_%D0%B3%D1%80%D0%B0%D1%84)
5. Свободная энциклопедия "Википедия" \[Электронный ресурс\]. – Режим доступа: [https://ru.wikipedia.org/wiki/Разрез_(теория_графов)](https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D0%B7%D1%80%D0%B5%D0%B7_(%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D0%B3%D1%80%D0%B0%D1%84%D0%BE%D0%B2))
6. Свободная энциклопедия "Википедия" \[Электронный ресурс\]. – Режим доступа: [https://ru.wikipedia.org/wiki/Полный_перебор](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%BB%D0%BD%D1%8B%D0%B9_%D0%BF%D0%B5%D1%80%D0%B5%D0%B1%D0%BE%D1%80)

