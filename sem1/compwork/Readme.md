
# Расчётная работа.
## Тема работы
Тема работы - основы теории графов, базовые алгоритмы на графах.
## Цель работы
- Ознакомиться с понятием графа.
- Ознакомится с основными типами графов.
- Ознакомиться с различными способами представления графов.
- Научиться решать теоретико-графовые задачи.
## Задачи
- Необходимо разработать и реализовать программу на С/С++, которая решает выданную преподавателем теоретико-графовую задачу и соответствует следующим требованиям:
    - Если преподаватель указал определенную структуру данных для представления графа, то в программе должна быть использована именно эта структура данных.
    - Использование глобальных переменных в программе недопустимо.
    - При своем запуске программа должна в автоматическом режиме стартовать 5 разнообразных примеров решения задачи и выводить результаты работы на консоль.
    - В программе должна оптимальным образом использоваться возможность языка программирования С/С++ по созданию функций.
    
 ## Вариант
 5.3(Реализовать Гамильтонов цикл в невзвешенном,неориентированном графе).

### Ключевые понятия
`Граф` - математическая абстракция реальной системы любой природы, объекты которой обладают парными связями.

`Ориентированный граф (кратко орграф)` —  граф, рёбрам которого присвоено направление.

`Список смежности` - один из способов представления графа в виде коллекции списков вершин. Каждой вершине графа соответствует список, состоящий из «соседей» этой вершины.

`Матрица смежности` - это вид представления графа в виде матрицы, когда пересечение столбцов и строк задаёт дуги.

`Путь в графе` – это последовательность рёбер, в которой конец каждого ребра (кроме последнего) совпадает с началом следующего.
Замкнутый путь называется `циклом`. 

## Алгоритм решения
1. Основная идея: Мы будем использовать метод обратного хода (backtracking) для поиска гамильтонова цикла. Начнем с произвольной вершины и будем рекурсивно добавлять вершины в путь, проверяя, можно ли их добавить без нарушений.

2. Проверка безопасности (isSafe): Функция isSafe проверяет, можно ли добавить текущую вершину в путь:

Она должна быть смежна с последней вершиной в текущем пути.

Вершина не должна уже присутствовать в пути (чтобы избежать повторений).

3. Рекурсивная функция (hamCycleUtil):

Базовый случай: Если все вершины посещены (позиция равна количеству вершин), проверяем, смежна ли последняя вершина в пути с первой вершиной. Если да, значит найден гамильтонов цикл.

Рекурсивный случай: Для каждой вершины, начиная с 1 (так как 0 уже в пути), проверяем, можно ли её добавить в текущий путь. Если да, добавляем её и рекурсивно вызываем функцию для следующей позиции. Если цикл найден, возвращаем истину. Если нет, убираем вершину из пути (backtracking).

4. Инициализация и запуск: Мы создаем массив path, чтобы хранить текущий путь. Инициализируем первую вершину как начальную точку и вызываем рекурсивную функцию.

Вот краткая схема алгоритма:

Инициализируем path и добавляем в него первую вершину.

Вызываем hamCycleUtil для следующей позиции.

В hamCycleUtil:

Проверяем, не достигли ли конца пути.

Для каждой вершины:

Проверяем, безопасно ли её добавить.

Если безопасно, добавляем её и вызываем hamCycleUtil для следующей позиции.

Если цикл найден, возвращаем истину.

Если нет, убираем вершину из пути (backtracking).

Если рекурсивная функция возвращает истину, выводим найденный путь. Если нет, говорим, что решения не существует.

Таким образом, алгоритм перебирает все возможные пути, чтобы найти гамильтонов цикл, используя обратный ход для возвращения на предыдущий шаг, если текущий путь не ведет к решению.

Надеюсь, это поможет! Если у тебя есть еще вопросы, не стесняйся спрашивать!

## Реализация на C++
```
#include <iostream>
#include <vector>
#include <windows.h>

void printSolution( std::vector<int>& path,int V) {
    std::cout << "Гамильтонов цикл: ";
    for (int i = 0; i < V; i++)
        std::cout << path[i] << " ";
    std::cout << path[0] << std::endl;
}

bool isSafe(int v, std::vector<std::vector<bool>>& graph, std::vector<int>& path, int pos) {
    if (!graph[path[pos - 1]][v])
        return false;

    for (int i = 0; i < pos; i++)
        if (path[i] == v)
            return false;

    return true;
}

bool hamCycleUtil(std::vector<std::vector<bool>>& graph,std::vector<int>& path, int pos,int V) {
    if (pos == V) {
        if (graph[path[pos - 1]][path[0]])
            return true;
        else
            return false;
    }

    for (int v = 1; v < V; v++) {
        if (isSafe(v, graph, path, pos)) {
            path[pos] = v;
            if (hamCycleUtil(graph, path, pos + 1,V))
                return true;
            path[pos] = -1;
        }
    }

    return false;
}

bool hamCycle(std::vector<std::vector<bool>>& graph,int V) {
    std::vector<int> path(V, -1);
    path[0] = 0;

    if (!hamCycleUtil(graph, path, 1,V)) {
        std::cout << "Решение не существует" << std::endl;
        return false;
    }

    printSolution(path,V);
    return true;
}

void runTests() {
    int v1 = 5;
    std::vector<std::vector<bool>> testGraph1 = { {0, 1, 0, 0, 1},
                                         {0, 1, 1, 0, 0},
                                         {0, 1, 0, 1, 0},
                                         {0, 0, 1, 0, 1},
                                         {1, 0, 0, 1, 0} };

    int v2 = 5;
    std::vector<std::vector<bool>> testGraph2 = { {0, 1, 1, 0, 1},
                                        {1, 0, 0, 1, 1},
                                        {1, 0, 0, 1, 1},
                                        {0, 1, 1, 0, 1},
                                        {1, 1, 1, 1, 0}, };
    int v3 = 6;
    std::vector<std::vector<bool>> testGraph3 = { {0, 1, 1, 0, 0, 0},
                                        {1, 0, 0, 1, 0, 0},
                                        {1, 0, 0, 1, 1, 0},
                                        {0, 1, 1, 0, 0, 1},
                                        {0, 0, 1, 0, 0, 1},
                                        {0, 0, 0, 1, 1, 0}, };
    int v4 = 5;
    std::vector<std::vector<bool>> testGraph4 = { {0, 1, 1, 0, 0},
                                        {0, 0, 0, 1, 0},
                                        {1, 0, 0, 1, 0},
                                        {1, 1, 1, 0, 1},
                                        {0, 0, 0, 1, 0}, };
    int v5 = 5;
    std::vector<std::vector<bool>> testGraph5 = { {0, 1, 1, 0, 0},
                                        {0, 0, 0, 1, 1},
                                        {1, 0, 0, 1, 0},
                                        {1, 1, 1, 0, 1},
                                        {0, 1, 0, 1, 0}, };


    std::cout << "Тест 1: ";
    hamCycle(testGraph1,v1);

    std::cout << "Тест 2: ";
    hamCycle(testGraph2,v2);

    std::cout << "Тест 3: ";
    hamCycle(testGraph3, v3);

    std::cout << "Тест 4: ";
    hamCycle(testGraph4, v4);

    std::cout << "Тест 5: ";
    hamCycle(testGraph5, v5);

}

int main() 
{
    int V = 5;
    std::vector<std::vector<bool>> graph(V, std::vector<bool>(V, false));
    SetConsoleCP(1251);
    SetConsoleOutputCP(1251);
    runTests();
    return 0;
}
```

## Тесты
1.
![Снимок экрана 2024-12-18 182710](https://github.com/user-attachments/assets/0b514134-4b46-4872-82a4-89c982bb41db)
Ввод:
```
0 1 1 0 1
1 0 0 1 1
1 0 0 1 1
0 1 1 0 1
1 1 1 1 0
```
Вывод:
![Снимок экрана 2024-12-18 185117](https://github.com/user-attachments/assets/2c606e21-41ae-4863-b2d8-6179a3ddf159)

2.
![Снимок экрана 2024-12-18 182556](https://github.com/user-attachments/assets/e05936fa-98cc-4005-b5f1-5a3b67cd984d)
Ввод:
```
0 1 1 0 1
1 0 0 1 1
1 0 0 1 1
0 1 1 0 1
1 1 1 1 0
```
Вывод:
![image](https://github.com/user-attachments/assets/fd354c3b-214f-4567-bc8f-d149dd4e5343)

3.
![Снимок экрана 2024-12-18 183435](https://github.com/user-attachments/assets/7c3dc9fb-d1cc-47a3-922b-f4300b42b25c)

Ввод:
```
0 1 1 0 0 0
1 0 0 1 0 0
1 0 0 1 1 0
0 1 1 0 0 1
0 1 0 0 0 1
0 0 0 1 1 0
```
Вывод:
![image](https://github.com/user-attachments/assets/a000d1d2-efee-4bc3-b169-bc0aaa57ea4a)

4.
![Снимок экрана 2024-12-18 184252](https://github.com/user-attachments/assets/e566e1e2-7231-4ac9-81fb-e698765a40ec)

Ввод:
```
0 1 1 0 0
0 0 0 1 0
1 0 0 1 0
1 1 1 0 1
0 0 0 1 0
```
Вывод:
![image](https://github.com/user-attachments/assets/8404ec0a-a568-4baf-9657-e20c39075fcd)

5.
![image](https://github.com/user-attachments/assets/f69f7e98-d017-4f2a-b211-64c0d6e4c493)
Ввод:
```
0 1 1 0 0
0 0 0 1 1
1 0 0 1 0
1 1 1 0 1
0 1 0 1 0
```
Вывод:
![image](https://github.com/user-attachments/assets/67a40b21-9a82-409f-9f20-5f034209d8fa)

## Вывод
 
В результате выполнения расчётной работы приобрёл следующие навыки:
- изучил основы теории графов
- изучил способы представления графов
- изучил базовые алгоритмы для работы с графами
- изучил базовые алгоритмы работы с векторами в C++

## Список литературы
[1] Оре О. Теория графов. – 2-е изд.. – М.: Наука, 1980. – С. 336.

[2] Кормен Т. Х. и др. Часть VI. Алгоритмы для работы с графами // Алгоритмы: построение
и анализ = Introduction to Algorithms. – 2-е изд.. – М.: Вильямс, 2006. – С. 1296.

[3] Харари, Ф. Теория графов / Ф. Харари / Пер. с англ. и предисл. В.П. Козырева. Под ред.
Г.П. Гаврилова. Изд. 2-е. – М.: Едиториал УРСС, 2003. – 269 с.








