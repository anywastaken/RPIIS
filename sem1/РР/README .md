<h1>Расчетная работа</h1>

<h2>Цель</h2>
<p>Изучить основы теории графов, способы представления графов, базовые алгоритмы для работы с графами.</p>

<h2>Задание 2.13(ми)</h2>
<p>Реализовать на C++ код, который ищет численное значение обхвата орграфа. Граф вводится в виде матрицы инцидентности.</p>

<h2>Ключевые понятия</h2>

`Граф` - математическая абстракция реальной системы любой природы, объекты которой обладают парными связями.

`Ориентированный граф (орграф)` —  граф, рёбрам которого присвоено направление.

`Матрица инцидентности` - один из способов представления графа в виде матрицы, в которой строки ссылаются на узлы графа, а столбцы на связи узлов.

`Путь в графе` – это последовательность рёбер, в которой конец каждого ребра (кроме последнего) совпадает с началом следующего.
Замкнутый путь называется `циклом`. 

`Обхват графа` — длина наименьшего цикла, содержащегося в данном графе. Если граф не содержит циклов (то есть является `ациклическим графом`), его обхват по определению равен бесконечности.

`Обход в ширину (breadth-first search, BFS)` — это алгоритм поиска в древовидной структуре данных узла, удовлетворяющего заданному свойству.

Картинка отображающая суть поиска в ширину:
![bfs](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D0%B0%D0%BF%D1%87%D0%B8%D0%BD%D1%81%D0%BA%D0%B8%D0%B9_%D0%92/%D0%A0%D0%A0/imgs/bfs.png)

<h2>Алгоритм решения</h2>

Выполняет поиск кратчайшего цикла в графе. Выполняем алгоритм поиска в ширину (BFS) для каждой вершины в графе, чтобы найти кратчайший цикл. Для этого запускаем BFS из каждой вершины, используя очередь для обхода графа.

Каждый раз, когда мы добавляем новую вершину в очередь, мы проверяем, есть ли у неё соседи, которые уже были посещены. Если мы обнаруживаем, что один из соседей уже был посещен и он соответствует начальной вершине, мы обновляем минимальную длину найденного цикла.

В конце концов, возвращаем минимальную длину цикла в графе. Если цикл не обнаружен, это указывает на ацикличность графа, и его обхват равен бесконечности.

Рассмотрим алгоримт на простом примере:<br>
Найдем обхват матрицы ниже<br>
![graph1](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D0%B0%D0%BF%D1%87%D0%B8%D0%BD%D1%81%D0%BA%D0%B8%D0%B9_%D0%92/%D0%A0%D0%A0/imgs/graph1.png)
```
Матрица инцидентности этого графа:
-1 0 0 1 0
1 -1 0 0 -1
0 1 -1 0 0
0 0 1 -1 1
```

1. Начинаем с вершины 1:

- Добавляем вершину 1 в очередь с расстоянием 0.

- Распространяемся по смежным вершинам: добавляем вершину 2 в очередь с расстоянием 1.

2. Переходим к вершине 2:

- Распространяемся по смежным вершинам: добавляем вершины 3 и 4 в очередь с расстоянием 2.

- Обнаруживаем, что смежная вершина 4 смежна с начальной вершиной 1, обновляем минимальное расстояние до цикла = 3.

3. Переходим к вершине 3:

- Распространяемся по смежным вершинам: добавляем вершину 4 в очередь с расстоянием 3.

- Обнаруживаем, что смежная вершина 4 смежна с начальной вершиной 1, но расстояние 4 больше минимального, поэтому не обновляем минимальное расстояние.

4. Переходим к вершине 4:

- Распространяемся по смежной вершине 1, но она уже была посещена, поэтому не добавляем в очередь.

Таким образом, минимальная длина цикла в данном графе равна 3.

<h2>Реализация на C++</h2>

```c++
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

int girth(vector<vector<int>>& matrix, int n, int m) {
    int mingirth = n + 1;

    for (int i = 0; i < n; i++) {
        vector<bool> visited(n, false);
        queue<pair<int, int>> q;
        q.push({ i, 0 });

        while (!q.empty()) {
            int cur = q.front().first;
            int dist = q.front().second;
            q.pop();

            for (int j = 0; j < m; j++) {
                if (matrix[cur][j] == 1) {
                    for (int neighbor = 0; neighbor < n; neighbor++) {
                        if (matrix[neighbor][j] == -1) {
                            if (neighbor == i) {
                                mingirth = min(mingirth, dist + 1);
                            }
                            else if (!visited[neighbor]) {
                                visited[neighbor] = true;
                                q.push({ neighbor, dist + 1 });
                            }
                        }
                    }
                }
            }
        }
    }

    if (mingirth == n + 1) {
        return -1;
    }
    else {
        return mingirth;
    }
}

int main() {
    setlocale(LC_ALL, "ru");
    int n, m;
    cout << "Введите количество вершин: ";
    cin >> n;
    cout << "Введите количество рёбер: ";
    cin >> m;

    vector<vector<int>> matrix(n, vector<int>(m, 0));
    cout << "Введите матрицу инцидентности: " << endl;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> matrix[i][j];
        }
    }

    int mingirth = girth(matrix, n, m);
    if (mingirth == -1) {
        cout << "Обхват графа: бесконечность" << endl;
    }
    else {
        cout << "Обхват графа: " << mingirth << endl;
    }

    return 0;
}

```
<h2>Разбор кода</h2>

```c++
#include <iostream>
#include <vector>
#include <queue>
using namespace std;
```
Эти строки представляют подключение необходимых библиотек. <iostream> обеспечивает доступ к стандартным потокам ввода-вывода (например, cout и cin), <vector> используется для работы с векторами, а <queue> предоставляет функциональность очередей.
```c++
int girth(vector<vector<int>>& matrix, int n, int m) {
    int mingirth = n + 1;
```
Здесь начинается объявление функции girth, которая принимает матрицу matrix, а также количество вершин n и количество рёбер m. mingirth инициализируется значением n + 1.
```c++
for (int i = 0; i < n; i++) {
    vector<bool> visited(n, false);
    queue<pair<int, int>> q;
    q.push({ i, 0 });
```
Далее идёт цикл по вершинам графа. Для каждой вершины мы инициализируем вектор visited, чтобы отслеживать посещенные вершины, и очередь q для выполнения поиска в ширину. Начинаем с текущей вершины i и инициализируем расстояние как 0.
```c++
while (!q.empty()) {
    int cur = q.front().first;
    int dist = q.front().second;
    q.pop();
```
Этот цикл выполняет поиск в ширину, продолжая до тех пор, пока очередь не станет пустой. Мы извлекаем вершину и её расстояние из начала очереди.
```c++
for (int j = 0; j < m; j++) {
    if (matrix[cur][j] == 1) {
        for (int neighbor = 0; neighbor < n; neighbor++) {
            if (matrix[neighbor][j] == -1) {
                if (neighbor == i) {
                    mingirth = min(mingirth, dist + 1);
                }
                else if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    q.push({ neighbor, dist + 1 });
                }
            }
        }
    }
}
```
Здесь мы перебираем рёбра для текущей вершины. Если мы обнаружим ребро, мы проверяем соединенную с ним вершину (соседа) и обновляем mingirth, если находим цикл. Если нет, мы обозначаем соседа как посещенного и добавляем его в очередь.
```c++
if (mingirth == n + 1) {
    return -1;
}
else {
    return mingirth;
}
```
Этот блок кода проверяет, был ли найден кратчайший цикл. Если нет, возвращаем -1, обозначая бесконечное расстояние, в противном случае возвращаем кратчайшее расстояние.
```c++
int main() {
    // ... (ввод данных)
    int mingirth = girth(matrix, n, m);
    if (mingirth == -1) {
        cout << "Обхват графа: бесконечность" << endl;
    }
    else {
        cout << "Обхват графа: " << mingirth << endl;
    }
    return 0;
}
```
В main функции происходит ввод данных и вызов функции girth. Затем в зависимости от результата выводится найденное значение кратчайшего цикла или сообщение о том, что цикл не найден.


<h2>Тесты</h2>

```
граф 1
-1 0 0 1 0
1 -1 0 0 -1
0 1 -1 0 0
0 0 1 -1 -1
Обхват: 3
```
![graph1](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D0%B0%D0%BF%D1%87%D0%B8%D0%BD%D1%81%D0%BA%D0%B8%D0%B9_%D0%92/%D0%A0%D0%A0/imgs/graph1.png)
```
граф 2
-1 0 1
1 -1 0
0 1 -1
Обхват: 3
```
![graph2](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D0%B0%D0%BF%D1%87%D0%B8%D0%BD%D1%81%D0%BA%D0%B8%D0%B9_%D0%92/%D0%A0%D0%A0/imgs/graph2.png)
```
граф 3
-1 0 0 0 1
1 -1 0 0 0
0 1 -1 0 0
0 0 1 -1 0
0 0 0 1 -1
Обхват: 5
```
![graph3](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D0%B0%D0%BF%D1%87%D0%B8%D0%BD%D1%81%D0%BA%D0%B8%D0%B9_%D0%92/%D0%A0%D0%A0/imgs/graph3.png)
```
граф 4
-1 0 0 0 1 -1
1 -1 0 0 0 0
0 1 -1 0 0 0
0 0 1 -1 0 1
0 0 0 1 -1 0
Обхват: 3
```
![graph4](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D0%B0%D0%BF%D1%87%D0%B8%D0%BD%D1%81%D0%BA%D0%B8%D0%B9_%D0%92/%D0%A0%D0%A0/imgs/graph4.png)
```
граф 5
-1 0 0 0 0 0 1 0 0 0
1 -1 0 0 0 0 0 -1 -1 0
0 1 -1 0 0 0 0 0 0 -1
0 0 1 1 0 0 0 0 0 0
0 0 0 -1 -1 0 0 0 1 1
0 0 0 0 1 -1 0 1 0 0
0 0 0 0 0 1 -1 0 0 0
Обхват: 4
```
![graph5](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D0%B0%D0%BF%D1%87%D0%B8%D0%BD%D1%81%D0%BA%D0%B8%D0%B9_%D0%92/%D0%A0%D0%A0/imgs/graph5.png)
```
граф 6
-1 0 0 0 1
1 -1 0 -1 0
0 1 0 0 0
0 0 0 1 -1
Обхват: бесконечность
```
![graph6](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D0%B0%D0%BF%D1%87%D0%B8%D0%BD%D1%81%D0%BA%D0%B8%D0%B9_%D0%92/%D0%A0%D0%A0/imgs/graph6.png)

<h2>Вывод</h2>

В результате выполнения расчётной работы приобрёл следующие навыки:
- изучил основы теории графов
- изучил способы представления графов
- изучил базовые алгоритмы для работы с графами
- изучил базовые алгоритмы работы с векторами, очерядими и файлами в C++
